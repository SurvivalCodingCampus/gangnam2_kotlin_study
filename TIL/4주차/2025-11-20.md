# Test 이론

## 1️⃣ 테스트 더블 (Test Double)

- 테스트가 진행하기 어려운 경우에, 테스트가 가능하도록 만들어주는 객체
- 종류:
    - Fake
    - Stub
    - Spy
    - Dummy
    - Mock
- 실무에서는 대부분 **Mock**만 알아도 어느 정도 대응 가능

---

## 2️⃣ Mock 객체 활용

단위 테스트는 라이브 웹 서비스 또는 데이터베이스에서 데이터를 가져오는 클래스에 의존할 수 있다.

이 경우 문제점:

- 테스트 실행 속도가 느려진다.
- 예기치 않은 결과를 반환하면 통과하던 테스트가 실패하기 시작할 수 있다.
- 가능한 모든 성공 및 실패 시나리오를 테스트하는 것은 어렵다.

따라서:

- 라이브 웹 서비스나 데이터베이스에 의존하는 대신  
  이러한 **종속성(Dependency)을 Mocking**하여 테스트한다.

---

## 3️⃣ 의존성과 테스트

- 의존성이 강하면 테스트가 어렵다.
    - 의존하고 있는 모든 컴포넌트를 함께 확인해야 하기 때문
- 해결 방법:
    - **다형성**을 활용
    - **인터페이스**를 통해 의존성 주입(Dependency Injection)
- 요즘은 코틀린 환경에서 **MockK**를 많이 사용

---

## 4️⃣ Repository와 모델, 도메인

### Repository의 역할 비유

- Repository는 재료(데이터) 전처리에 비슷한 역할
- 모델 객체 클래스의 속성에 대한 데이터를 조회할 수 있는 클래스
- 별도의 비즈니스 기능을 가지지 않는 **순수한 클래스**
- 데이터소스로부터 받은 데이터를 앱에서 필요한 형태로 변환하여  
  앱 개발을 편리하게 해 주는 역할

---

## 5️⃣ View에 보여질 데이터를 담는 객체

- View에 전달할 데이터를 담는 객체 (예: DTO, ViewModel 등)

비슷한 용어들:

- 도메인 모델 (Domain Model)
- Entity
- DTO (Data Transfer Object)
- POJO (Plain Old Java Object)
- VO (Value Object)
- 데이터 클래스 (Kotlin data class)

---

## 6️⃣ DDD (Domain-Driven Design)

### Domain의 정의

- 유사한 업무의 집합
- 특정 상황(주문, 결제, 로그인)이나  
  특정 객체(유저, 손님)가 중심이 될 수 있음

---

## 7️⃣ Repository 패턴

### 정의

- 소프트웨어 개발에서 **데이터 저장소에 접근하는 객체를 추상화**하고,  
  **데이터소스(DB, File 등)와의 통신을 담당하는 객체를 캡슐화**하는 디자인 패턴

### Repository의 책임과 역할

- 데이터 접근의 진입점
- 데이터 접근에 대한 추상화 계층
- 데이터 소스 은닉
- 비즈니스 로직과 데이터 소스 사이의 중재자
- 데이터 매핑, 변환 담당

### Repository 패턴의 이점

- **데이터 접근 추상화**
    - 데이터 소스 구현 세부사항 은닉
    - 일관된 인터페이스 제공
- **유지보수성 향상**
    - 관심사 분리
    - 코드 재사용성
- **테스트 용이성**
    - 데이터 소스 Mocking 가능
    - 단위 테스트 작성 용이
- **확장성**
    - 새로운 데이터 소스 추가 용이
    - 기존 코드 수정 최소화
    - 인터페이스 기반 설계

---

## 8️⃣ Repository의 핵심 역할 정리

- 데이터 소스를 숨기고, 상위 계층에서 **일관된 방법으로 데이터에 접근**할 수 있도록 제공
- 데이터를 비즈니스 로직에 전달

---

## 9️⃣ 도메인 특화 기능을 Repository가 제공하는 경우의 장점

- 도메인 의도가 명확히 드러남
- 재사용 가능한 쿼리 로직 제공
- 데이터 소스 구현과 분리된 비즈니스 요구사항 처리

---

## 🔟 Repository와 DataSource의 역할 분리

- Repository는 **어떤 데이터를 전달할지**에 집중
    - 직접적인 데이터 조작보다는 **필요한 데이터를 골라내는 일**을 수행
- 실제 저장 매체(DB, File, Network 등)를 다루는 코드는 **DataSource**에서 처리
- 복잡한 비즈니스 로직은 더 **상위 계층(UseCase, Service, Domain Layer 등)**으로 올리는 것이 좋다