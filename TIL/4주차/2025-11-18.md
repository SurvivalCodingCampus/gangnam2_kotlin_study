# 스레드(Thread), 비동기 프로그래밍

## 1️⃣ 스레드(Thread)

### 스레드의 정의

- 프로세스 내에서 실행 흐름을 담당하는 **가장 작은 실행 단위**
- 하나의 프로세스 안에 여러 스레드가 존재할 수 있으며, 메모리(힙, 코드 영역 등)를 공유한다.

### 자바에서의 스레드

- `java.lang.Thread` 클래스를 사용하거나 `Runnable`을 구현해 생성
- 주요 메서드
    - `start()` : 새로운 스레드를 생성하고, `run()` 메서드를 비동기로 실행
    - `join()` : 해당 스레드가 종료될 때까지 대기(블로킹)
    - `sleep(ms)` : 현재 스레드를 지정한 시간 동안 일시 정지(블로킹)
- 스레드는 OS 스레드와 1:1 매핑되는 경우가 많아, 생성/전환 비용이 크고 개수를 과도하게 늘리기 어렵다.

### 교착 상태(Deadlock) 위험성

- 둘 이상 스레드가 **서로가 가진 자원을 기다리며 무한 대기**에 빠지는 상태
- 예시
    - 스레드 A: 자원 1을 잡고 자원 2를 기다림
    - 스레드 B: 자원 2를 잡고 자원 1을 기다림
- 발생 원인
    - 상호 배제, 점유와 대기, 비선점, 순환 대기 조건이 동시에 성립할 때
- 스레드 기반 설계에서는 락(lock) 사용 시 순서, 범위, 시간 제한 등을 신중히 설계해야 한다.

---

## 2️⃣ 비동기 프로그래밍(Asynchronous Programming)

### 동기 vs 비동기

- **동기(Synchronous)**
    - 코드가 순서대로 실행된다.
    - 한 작업이 끝날 때까지 다음 작업은 **기다렸다가** 실행된다.
    - 작업이 완료될 때까지 해당 흐름(스레드)은 블로킹된다.
    - 실행 순서가 예측 가능하지만, 오래 걸리는 작업에 대해서는 비효율적이다.

- **비동기(Asynchronous)**
    - 한 작업의 완료 여부와 관계없이 다음 작업을 시작할 수 있다.
    - 오래 걸리는 작업을 **백그라운드에서 처리**하고, 끝났을 때 콜백/이벤트/Promise/코루틴 등으로 결과를 전달한다.
    - 작업 완료 순서는 예측하기 어렵지만, 자원을 더 효율적으로 사용할 수 있다.
    - I/O, 네트워크, 파일 접근 등 **대기 시간이 긴 작업**에 특히 유용하다.
    - 예) Java에서는 `Thread`, `Executor`, `CompletableFuture` 등, Kotlin에서는 **Coroutine**이 대표적인 비동기 수단.

---

## 3️⃣ 동시성 vs 병렬성

### 동시성(Concurrency)

- 여러 작업이 **논리적으로 동시에 실행되는 것처럼 보이는** 개념
- 실제로는 하나의 코어에서 시분할 방식으로 번갈아 실행될 수 있다.
- 주요 목표: **응답성 향상, 구조적인 작업 분리**
- 하나의 코어 + 여러 스레드/코루틴을 통해 구현할 수 있다.

### 병렬성(Parallelism)

- 여러 작업이 **물리적으로 동시에 실행되는** 개념
- 멀티코어/멀티CPU 환경에서 각각의 코어가 다른 작업을 실제로 동시에 처리
- 주요 목표: **처리량(Throughput) 향상**
- 동시성은 설계 개념, 병렬성은 하드웨어/실행 방식에 가까운 개념으로 구분할 수 있다.

---

## 4️⃣ 코루틴(Coroutine)

### 코루틴 개요

- Kotlin에서 제공하는 **경량 비동기/동시성 프로그래밍 API**
- 오래 걸리는 작업을 수행할 때, **스레드를 차단하지 않고** 일시 중단(suspend)할 수 있는 실행 단위
- 비동기 코드를 **동기 코드처럼 순차적으로** 작성할 수 있게 도와준다.
- 스레드 위에서 동작하지만, 하나의 스레드에서 수천 개의 코루틴을 띄워도 부담이 적다.

### 자바의 스레드에 비해 코틀린 코루틴의 장점

- **경량성**
    - 코루틴 생성/전환 비용이 스레드보다 훨씬 작다.
    - 같은 수의 작업을 위해 스레드를 직접 만드는 것보다 메모리와 자원 사용량이 적다.

- **구조적 동시성(Structured Concurrency)**
    - `CoroutineScope`를 통해 코루틴의 생명주기를 구조적으로 관리한다.
    - 부모 스코프가 취소되면 자식 코루틴도 함께 취소되어, **메모리 누수 작업을 방지**한다.

- **기본 취소 지원**
    - `suspend` 지점에서 취소 여부를 체크하며 자연스럽게 종료된다.
    - 별도의 플래그 관리보다 선언적이고 안전한 취소가 가능하다.

- **표현력 좋은 API**
    - `suspend fun`, `launch`, `async`, `withContext` 등을 통해
      콜백 기반 코드보다 **가독성이 좋고 예외 처리도 간단**하다.

- **플랫폼/라이브러리 지원**
    - Kotlin 표준 라이브러리, Android, Ktor 등에서 코루틴을 1급 시민으로 지원한다.

---

## 5️⃣ 콜백 지옥(Callback Hell)

- 비동기 작업을 **중첩된 콜백**으로만 표현할 때 생기는 문제
- 특징
    - 들여쓰기가 깊어져 코드가 오른쪽으로 계속 밀린다.
    - 에러 처리와 흐름 제어가 복잡해진다.
    - 재사용성과 유지보수성이 떨어진다.
- 예)
    - A 작업 완료 후 콜백에서 B 호출, 그 콜백에서 C 호출… 형태로 계속 중첩
- 코루틴/Promise/async–await는 이러한 콜백 지옥을 완화하기 위해 등장한 추상화라고 볼 수 있다.

---

## 6️⃣ 코루틴 빌더(Coroutine Builder)

- **새로운 코루틴을 시작하는 함수**
- 대표 예시
    - `runBlocking { ... }`
    - `launch { ... }`
    - `async { ... }`
    - `withContext(Dispatcher) { ... }`
- 코루틴 빌더는 내부적으로 **CoroutineScope**를 바탕으로 코루틴을 생성하며,
  구조적 동시성 규칙에 따라 코루틴의 생명주기를 관리한다.

### 대표 빌더 정리

#### `launch`

- 반환값: `Job`
- **결과가 필요 없는 비동기 작업**에 사용
- 주요 메서드
    - `join()` : 해당 코루틴이 끝날 때까지 대기(비동기적으로 완료를 기다릴 때 사용)
    - `cancel()` / `cancelAndJoin()` : 코루틴 취소 및 취소 완료까지 대기

#### `async`

- 반환값: `Deferred<T>`
- **결과가 필요한 비동기 작업**에 사용
- `await()`를 호출해 결과를 가져올 수 있으며, `Deferred`는 일종의 코루틴 기반 Future/Promise 역할을 한다.

#### `runBlocking`

- 반환값: 제네릭 타입 `T` (블록의 마지막 표현식 결과)
- **일반 블로킹 코드와 코루틴 세계를 연결**할 때 사용
    - 예: `main` 함수, 단위 테스트 등
- 내부에서 코루틴이 완료될 때까지 **현재 스레드를 차단**하므로, 일반 애플리케이션 코드(특히 UI 스레드)에서는 남용하지 않는다.

---

## 7️⃣ `suspend` 키워드

- **일시 중단(suspend) 가능한 함수**를 표기하는 코틀린 문법
- `suspend fun`은
    - 호출한 스레드를 차단하지 않고, **코루틴을 일시 정지할 수 있는 지점**을 포함한다.
    - 나중에 다시 재개(resume)될 수 있으며, 그 사이에 같은 스레드에서 다른 코루틴/작업이 실행될 수 있다.
- 예: `delay(timeMillis: Long)` 는 대표적인 `suspend` 함수로,
  지정한 시간 동안 코루틴을 **일시 정지**하지만 스레드는 차단하지 않는다.

---

## 8️⃣ Dispatcher

- **코루틴이 어떤 스레드/스레드풀에서 실행될지**를 결정하는 구성 요소
- `CoroutineDispatcher` 구현체를 통해 선택하며, 대표적으로 다음이 있다.

### `Dispatchers.Default`

- 기본 백그라운드 스레드풀
- CPU 코어 수에 비례하는 스레드를 사용
- **CPU 연산 위주 작업**(컬렉션 처리, 복잡한 계산 등)에 적합

### `Dispatchers.Main`

- 메인(UI) 스레드에 연결된 디스패처 (Android 등)
- UI 업데이트, 사용자 입력 처리 등 **UI 관련 작업**에 사용
- 메인 스레드를 블로킹하지 않도록, 오래 걸리는 작업은 다른 디스패처와 함께 사용해야 한다.

### `Dispatchers.IO`

- I/O 작업에 최적화된 백그라운드 스레드풀
- 상대적으로 많은 수의 스레드를 사용하여 **파일, DB, 네트워크 I/O** 등에 적합

### `withContext`

- 현재 코루틴을 **다른 디스패처 컨텍스트로 전환**할 때 사용
- 예)
    - `withContext(Dispatchers.IO) { 파일 읽기 }`
    - `withContext(Dispatchers.Main) { UI 갱신 }`
- 하나의 `suspend` 함수 안에서 필요한 작업마다 적절한 디스패처를 선택해 사용할 수 있다.
