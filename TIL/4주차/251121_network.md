## 네트워크 통신

### ClientFactory

- HttpClientFactory는 `HttpClient 생성 역할`
    ```kotlin
    HttpClientFactory.create()
    ```
- RemoteDataSourceImpl은 HttpClient를 `주입`받아 사용
    ```kotlin
    class RemoteDataSourceImpl(private val client: HttpClient)
    ```
- 실제 코드에서 이렇게 연결
    ```kotlin
    val dataSource = RemoteDataSourceImpl(HttpClientFactory.create())
    ```

### URL을 활용한 고수준 액세스

- 고수준 : 사람이 이해하기 쉽게 작성된 프로그램 또는 API

#### JSON 개념

- 서버-클라이언트 통신에서 표준처럼 사용되는 데이터 교환 형식
- 가볍고 사람이 읽기 쉽다
- Map 과 같은 key-value 구조
- 직렬화하여 문자열로 나타내기 쉽다
- 대부분의 언어가 이를 파싱할 수 있기 때문에 상호 운용성은 걱정할 것이 없음

#### HTTP 개념

- HyperText Transfer Protocol
- 원래 문서 전송용으로 설계된 상태 비저장용 프로토콜
- 브라우저가 GET 요청으로 웹 서버의 문서를 읽어오는 용도였음
- 지금은 서버와 클라이언트가 텍스트, 이미지, 동영상 등의 데이터를 주고 받을 때 사용하는 프로토콜로 확장됨
- 웹 상에서 보는 이미지, 영상, 파일과 같은 바이너리 데이터도 HTTP 멀티파트나 Base64 인코딩하여 사용

#### 무상태성

- HTTP 는 상태 비저장 프로토콜
- HTTP는 요청 메시지를 보내기 직전까지 대상 컴퓨터가 응답 가능한지 알 방법이 없음
- Stateless 프로토콜, 즉 상태가 없는 프로토콜이라고 함
- Stateful 프로토콜로는 TCP (Transmission Control Protocol)가 있음

#### HTTP 요청과 응답

- 모든 HTTP 메시지는 요청과 응답이 일대일로 대응되어야 함
    - 장점: 클라이언트는 항상 자신이 보낸 요청에 대한 응답을 알 수 있어서 로직이 단순해짐
    - 단점: 클라이언트는 서버로 HTTP 요청을 보내기 직전까지 실제로 서버가 동작하는지 알 방법이 없음
- 응답 없음
    - 일정시간 응답이 없을 경우 요청 실패
    - 실제로 서버가 제대로 처리를 했어도 응답이 늦게 와서 타임아웃 나는 경우도 있음
        - 안드로이드: 10초
        - ios: 60초
        - 크로스 플랫폼: 안드로이드 기준
- 예측이 어려운 HTTP 응답 없음
    - 서버가 다른 국가에 있는 경우
    - 클라우드 기반의 서버
    - MockServer 를 활용한 테스트 필요

### 그외 통신 프로토콜

#### Socket 을 활용한 저수준 액세스

> 저수준 : 컴퓨터가 이해하기 쉽게 작성된 프로그램 또는 API

- TCP / UDP 를 추상화한 개발자를 위한 API
- 프로토콜이 아님
- 그래서 OSI 7계층에 포함되지 않음

#### TCP

> 신뢰성 있는 연결지향성 앱에서 사용 (이메일, 파일 전송, 웹브라우저)

- Stateful 프로토콜
- 연결되면 연결을 끊기 전까지 계속 메시지를 주고 받는 프로토콜
- 한쪽에 문제가 생기면 다른쪽에서 감지 가능
- 텍스트가 아닌 바이너리 데이터를 전송
- 패킷 크기가 HTTP에 비해 작음 → 속도 빠름
- 각 요청이 소켓 1개를 공유 (HTTP는 각 요청이 소켓 1개씩 사용)
    - 따라서 요청을 식별할 식별자가 필요
- 응답을 알 수 있는 방법이 없기 때문에 타임아웃에 대해 직접 구현해야 함

#### TCP / IP

- Socket 을 사용하여 TCP/IP 통신을 할 수 있음
- 접속하기 위해 IP 주소와 포트 번호가 필요
- 프로토콜(통신시 사용되는 데이터 형식이나 순서 등)은 RFC 문서에 정해둔 것을 따름
- 웹페이지 접속, 메일 전송, 게임 등은 모두 TCP/IP 를 통한 통신

#### UDP

> 신속한 데이터 전송이나 손실 가능성이 있는 상황에 주로 사용

- 비연결형 프로토콜
- 데이터 전달 보장이 안되어 신뢰성이 낮음
- 흐름 제어 없음
- 단순성
- 멀티캐스팅 및 브로트캐스팅

### 요청메서드

- 요청의 형태를 정의하는 키워드
- 상황에 맞게 사용하는 것이 관례
    - GET : 데이터 요청
    - POST : 데이터가 포함된 요청
    - DELETE : 삭제
    - PUT : 전부 업데이트
    - PATCH : 일부 업데이트

#### GET

- 일반적으로 웹 브라우저가 서버에 웹 페이지를 요청할 때 사용
- 읽기 요청
- body를 포함할 수 없음
- ?와 & 문자를 사용하는 쿼리 파라미터를 추가할 수 있음

#### POST

- 웹브라우저로 테스트 불가
- 클라이언트에서 서버로 데이터가 포함된 요청을 보낼 때 사용
- 로그인, 주문 요청 등
- 쿼리 파라미터뿐만 아니라 body로 데이터 전송

#### DELETE, PUT, PATCH

- 웹브라우저로 테스트 불가
- **DELETE** : 삭제
- **PUT** : 전체 업데이트
- **PATCH** : 일부 업데이트

#### HTTP 요청 헤더

- 요청 정보를 파악하는 데 도움이 되는 다른 여러 정보를 포함할 수 있음
- 주로 인증, 캐싱, 클라이언트 힌트, 조건, 연결 관리, 쿠키, CORS 등에 활용
- JSON 파일을 주고 받을 때 Content-Type 에 application/json 으로 명시

#### 상태 코드

> 모든 HTTP 응답에는 상태 코드와 상태 메시지가 있음

- 200 OK
- 400 Bad Request
- 404 Not Found
- 500 Internal Server Error

#### 세션과 쿠키

- HTTP는 상태라는 개념이 존재하지 않기 때문에 세션과 쿠키를 사용해 구분
- 주로 웹에서 서버는 세션, 클라이언트는 쿠키를 통해 상태 저장
- 모바일에 없는 개념

### RESTful API

> REST (representational state transfer) <br/>
> 서버와 클라이언트가 메시지를 주고받을 때 가장 많이 사용하는 통신 규격 (암묵적인 룰)

- REST: 분산 시스템을 위한 소프트웨어 아키텍처의 한 형태
- RESTful 이란 REST 조건을 만족한다는 뜻
- 요청 주소(URL)과 메서드(GET, POST 등), JSON 규격을 이용하여 API를 정의
- 오늘날 가장 범용적으로 사용
