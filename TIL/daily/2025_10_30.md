# TIL

## 2025-10-30 - 클래스

### 클래스

- 코틀린은 모든 타입이 레퍼런스 타입
- 모든 클래스는 반드시 1개 이상의 생성자를 가진다
- 가상세계 : 컴퓨터의 메모리 영역
- 인스턴스 : heap 영역 안에 확보된 메모리

#### 메모리

- 여러 개의 구역으로 나누어져 있고 구역마다 역할이 다르다
- heap
  - 객체를 저장하는 공간, 동적 할당
- stack
  - 메서드 호출 시 사용되는 지역변수 & 함수 호출 정보를 저장하는 공간
  - `val hero = Hero(name = "~~", ~~~)` 인 경우 Hero의 주소 정보 저장

```kotlin
val hero1 = Hero(name = "홍길동", hp = 100)
val hero2 = hero1
hero2.hp = 200
```

- 이런 경우 hero1 의 hp는 200
  - `val hero2 = hero1` 이라면 주소값을 넘겨주기 때문에 똑같은 인스턴스를 바라보고 있다

#### 가비지 컬렉션

- 주기적으로 메모리를 사용 안하는 것들을 삭제한다

### companion object

- 공유 자원, Java의 static 과 동일
- 정적
  - companion object 은 정적 <-> class 에 선언된 매개변수는 동적
- 각 인스턴스가 아닌, 클래스에 실체가 준비된다.
- 인스턴스를 생성하지 않아도 이용 가능하다.
- 다른 파일에서 접근하는 방식
  - companion object로 정의된 상수나 메서드는 MAX_HP가 아닌 Cleric.MAX_HP 로 클래스명을 앞에 붙여서 접근 가능
- 인스턴스 생성 전 초기화
  - companion object는 클래스의 인스턴스 생성 전에 실행되므로, 클래스 생성자 인수값 초기화 시에도 사용할 수 있다

#### const를 못붙이는 경우

```kotlin
const val randomMoney = Random.nextInt(10000)  // 이런거는 const를 붙일 수 없음.
```

- `Random` 은 런타임에 결정되는 것이기 때문에 `const` 를 붙일 수 없다.

## Test 방법론

- 수동 테스트 : 인간이 하는 테스트 (print)
- 단위 테스트 : 1개의 함수를 테스트 (test 코드)
- 통합 테스트 : 여러 개 연관된 클래스나 함수를 함께 테스트 (UI test, Integration test)

### 화이트 박스 테스트

- 내부 구조와 동작에 중점을 두고 테스트
- 구문 검사, 경로 검사, 조건/분기 검사

### 블랙 박스 테스트

- 소프트웨어 내부 구조를 무시하고 기능을 테스트
- 테스트 케이스는 입력 값과 예상 출력 값에 기반하여 설계
- 등가 분할, 경계 값 분석, 상태 전이 테스트

### 단위 테스트

- 특정 모듈이 의도한 대로 잘 작동하는가를 테스트하는 가장 작은 단위 테스트
- 모듈 : 메서드, 기능 !

### TDD (Test Driven Development)

- 테스트 중심으로 개발하는 방법론