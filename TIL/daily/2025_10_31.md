# TIL

## 2025-10-31 - 캡슐화 & 컬렉션

## 컬렉션 연습문제 1

```text
1. 대한민국의 도시 이름 모음 (순서 상관 없음)
    -> List,Set
2. 10명 학생의 시험 점수 
    -> List
3. 대한민국의 도시별 인구수 (순서 상관 없음)
    -> Map
```

----------

## 캡슐화

- 실수를 미연에 방지하기 위한 것
- 휴먼 에러를 없애기 위해 사용

### 멤버에 대한 엑세스 제어

**접근 지정자**

- `private` : 자기 자신의 클래스 접근 가능
- `public` : 모든 클래스 접근 가능
- 클래스도 private가 가능하지만 보통 공개할려고 클래스를 만들기 때문에 잘 안함!

### `getter` & `setter`

- 메소드를 경유한 필드 조작
- `getter` : 읽기 전용 프로퍼티를 구현할 때 사용
- `setter` : 쓰기 전용 프로퍼티를 구현할 때 사용 (잘 안 씀)

```kotlin
class Student(
    val id: Int,
    val name: String,
) {
}
```

- 이 프로퍼티 내부에 이미 getter,setter가 존재
- 만약 필드에 `val id: Int`-> var, `val` 을 제거하게 되면 `getter`, `setter` 생성되지 않음

#### getter 재정의

- `_age` : _를 붙이는 것은 관행 -> 내부적으로 수정가능한 변수라는 의미

```kotlin
class Student(
    val id: Int,
    val name: String,
    age: Int = 0,
) {
    private var _age = age
    val age: Int
        get() = _age

    fun study() {
        _age = 100
    }
}
```

### `setter` 에서 값의 타당성을 검사

```kotlin
class Hero(
    name: String,
    var hp: Int,
    var sword: Sword? = null,
) {
    var name: String = name
        set(value) {
            if (value.length <= 1) {
                throw IllegalArgumentException("이름이 너무 짧습니다.")
            }
            // ...
            field = value
        }

}
```

- setter를 통해 value.length 범위 검사 가능
- backing field : 프로퍼티의 값을 저장하기 위한 실제 필드 값 -> field로 접근 가능하다.
- `IllegalArgumentException` -> `require("~")` 로 간단하게 표현 가능하다.

## 컬렉션

### `Array`

- 크기가 정해져 있다.
- 속도가 빠르다
- 동적으로 크기를 늘리거나 줄이기에는 좋지 않음

### `list`

- 다음 데이터에 대한 주소 정보를 가지고 있다.
- 동적으로 데이터를 다루기 좋다
- 삽입 삭제가 빠르다 -> 삽입 삭제가 자주 일어나면 list 이용

### `list` vs `mutableList`

- 휴먼 에러를 줄이기 위해서는 list 를 사용
- 변수 상수와 마찬가지로 list 불변을 쓴다.

### set

- hash를 써서 빠르다.
- 중복을 허용하지 않음
- set 과 mutableSet
- `set.contains`는 속도가 매우 빠르다.

### map

- 키(key)와 값(value)의 쌍으로 이루어진 요소를 담는 자료구조
- 키의 중복을 허용하지 않는다.
- 객체지향이라면 map을 만들기보단 클래스를 만들어버린다~

### 컬렉션 선택

- key,value : Map
- 중복 가능 : List
- 중복 불가 : Set
- 순서 중요 : List
- 순서 안 중요 : Set
- 검색 속도 중요 : Set