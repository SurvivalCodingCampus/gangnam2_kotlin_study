# TIL

## 2025-11-10 - 다형성

-----
## 연습문제 1번
### (1)
- Sword 인스턴스
- Item 을 생성했지만 컴파일러에게는 Sword로 보임

### (2)
- val a: Monster = Slime()
- Slime 인스턴스
- Slime 을 생성했지만 컴파일러에게는 Monster로 보임

## 연습문제 2번
1. a() 
2. y1.a() = "Aa" / y2.a() = "Ba"

## 연습문제 3번
1. Y
2. 
```kotlin
fun main() {
    val y1 = A()
    val y2 = B()

    y1.a()
    y2.a()

    val list = mutableListOf<Y>()
    list.add(y1)
    list.add(y2)

    list.forEach {
        it.b()
    }
}
```

## 다형성
- 어떤 것을 이렇게도 부를 수 있고, 저렇게도 부를 수 있는 것
  - ex) 손흥민은 남자고, 축구선수이다.
  - 소나타는 차이면서, 기계이다.
- 관련이 거의 없는데 기능이 동일한 것은 인터페이스.
  - house.draw(), dog.draw() 등..

```kotlin
val drawable: Drawable = Rectangle(
    // ~~
)
val d: Drawable = elements[i]
```
- 실제 타입은 런타임에 결정된다.
- 실제 구현체의 draw() 메서드가 호출된다.

### 다형성을 활용하는 방법
- 선언을 상위 개념으로 인스턴스 생성은 하위 개념으로 한다.
- 추상적인 선언 = 상세 정의로 인스턴스화
```kotlin
val character: Character = Hero(name = "홍길동",hp = 100)
```

### cast
- as : 타입 캐스팅
```kotlin
val thing: Thing = Book(
        name = "홍길동",
        price = 100,
        color = "파랑",
        isbn = "121212",
        weight = 10.0
    )

    val thing2: Thing = Computer(
        name = "홍길동",
        price = 100,
        color = "파랑",
        markerName = "121212",
        weight = 10.0
    )

    val book5: Book = thing as Book
    val book6: Book = thing2 as Book
```
- 이렇게 강제 하는 것은 위험하다. thing2 같은 경우에는 Computer!

### smart cast
```kotlin
if (book6 is Book) {
    //~~~~
}
```
- is 를 통과하면 안전하다고 본다.


### 코드 중복 제거
```kotlin
fun main() {
    val characters: List<Character> = listOf(
        Hero("슈퍼맨"),
        Hero("배트맨"),
        Wizard("해리포터"),
        Wizard("제이나"),
    )
    
    characters.forEach { character ->  
        character.hp += 50
    }
}
```

- 다형성의 메리트 : 동일한 타입으로 취급

### 메소드 오버로딩
```kotlin
class Hero(name: String, hp: Int) : Character(name, hp) {
    override fun attack(slime: Slime) {
        //`~~
    }
    
    fun attack(goblin: Goblin) {
        // ~~~
    }
}
```
- attack을 할 때도 오버로딩을 여러 개 할 거를 attack(monster: Monster)로 해서 한번에 처리가 가능하다.

```kotlin
class Hero(name: String, hp: Int) : Character(name, hp) {
    override fun attack(monster: Monster) {
        //`~~
    }
}
```

### 정리

- **타입 간의 대입** - 상속에 의한 is-a 관계가 성립한다면, 인스턴스를 부모 클래스 타입의 변수에 대입 가능
#### 다형성
- 같은 부모를 가지는 다른 인스턴스를 동일시하여, 부모 클래스 타입에 담을 수 있다.
- 부모 클래스 타입의 인수나 리턴 값을 이용하여, 다른 클래스를 모아서 처리 가능
- 동일시 취급 해도, 각각의 인스턴스는 각 클래스의 정의를 따르고 다른 동작을 한다.