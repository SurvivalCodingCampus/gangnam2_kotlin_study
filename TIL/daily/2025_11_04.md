# TIL

## 2025-11-04 - 추상 클래스와 인터페이스

-----

## 추상클래스
 
- 상속의 재료로 사용 되는 클래스
- 상세 부분이 일부 미정인 클래스
- `abstract` 키워드 사용
- 예기치 않은 인스턴스화나 오버라이드의 미 구현의 걱정이 없다.
- open 키워드 없이 사용한다.
```kotlin
abstract class Character(
    // ~~~~
) {
     // ~~~
    abstract fun attack()
}
```
- 추상 클래스를 상속받으면 오버라이드를 강제하게 된다
- 추상 클래스는 인스턴스화가 금지되어 있다
- 클래스 다이어그램에서 추상 클래스/메서드 인 경우 이름이 이테릭 형태

## 인터페이스
- 모든 메서드는 추상 메서드여야 한다.
- 필드를 가지지 않는다.
- `abstract` 키워드가 생략되어 있다
- 비슷한 기능들을 모아논다
- 추상 메서드만 가지는 추상클래스 == 인터페이스
- 복수의 인터페이스를 부모로 두는 다중상속 효과가 가능 (하지만 이걸 다중 상속이라고 부르지 않는다)
- 인터페이스를 구현(implementation)한다고 한다.

### 인터페이스의 효과

- 같은 인터페이스를 구현한 클래스들은 공통 메소드를 구현하도록 강제된다.
- 어떤 클래스가 인터페이스를 구현하고 있다면, 적어도 그 인터페이스에 정의된 메소드를 가지고 있다는 것이 보장된다.
- 인터페이스는 여러 인터페이스를 구현할 수 있다.!

#### lateinit var & lazy
- 금지요
```kotlin
class Person {
    // .....
    val age2 = 0
    val age: Int by lazy { 
        0
    }
}
```

- 둘의 차이점 
  - `age2` : `Person`이 인스턴스화 될 때 `age2`가 메모리에 할당된다.
  - `age` : `age`라는 필드를 사용하는 순간에 메모리에 할당된다.

#### 상속의 재료를 작성하는 개발자의 입장 & 역할
- 다른 사람이 상속의 재료로 사용할 부모 클래스를 만드는 입장의 개발자도 존재
- 미래의 개발자가 효율 좋게 안심하고 이용할 수 있도록 작성해야 한다.