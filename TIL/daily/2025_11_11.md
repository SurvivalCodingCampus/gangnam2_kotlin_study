# TIL

## 2025-11-11 - 인스턴스 기본 조작

### Object
- Java 에서 모든 클래스는 Object 클래스의 메서드와 프로퍼티를 가지고 있다.
- Kotlin 에서는 Any, 근본은 Object

#### Object 클래스 대표 메서드
- `toString()` : 문자열 표현
- `equals()` : 비교 (Kotlin -> == 과 동일)
- `hashCode()` : 해시값을 얻는다.

### toString() 
- 디버깅용도로 재정의해서 씀.
- `override fun toString() ~~`

### equals()
- Java 에서 `==` 는 실제 주소 비교
- 코틀린에서는 다름
  - `==` : equals
  - `===` : 실제 주소 비교
- `equals()` 재정의를 통해 동등성 규칙을 정의할 수 있다.
- `List` 에서 동등성 비교 시 equals 사용
- `Set` 에서는 `hashCode` 사용

### hashCode()
- hashCode()를 재정의하면 Set, Map 내부에서의 동등성 규칙으로 사용 된다.


### Set, Map 의 동작 원리
- Set, Map 계열은 요소를 검색할 때 `hashCode` 를 사용하여 빠르다.
- List 는 순차 검색이라 느리다.
- 모든 객체는 해시값을 가진다.
- 동일한 객체는 항상 같은 해시값을 가진다.
- 하지만, 같은 해시값이라고 항상 동일한 객체는 아니다.
-> 해시값이 같다면 equals()까지 비교한다. // 다르다면 equals까지 가지 않는다!


### 확장 함수
```kotlin
fun main() {
    println("111".myFunction())
}

fun String.myFunction() : Int {
    return 10
}
```

### Compareable
- List.sorted() 메서드는 Comparable 을 구현한 객체를 가지는 컬렉션 내부를 정렬해준다.

### 예시
```kotlin
val results = hero.sortedWith { a, b -> a.name.compareTo(b.name) }
val results = hero.sortedWith(compareBy { it.name })

val results = hero.sortedBy { it.name }
```
- 결국 sortedBy()만 쓰면 된다~
```kotlin
open class Hero(
    var name: String = "",
    var hp: Int = 0,
    val maxHp: Int = MAX_HP
): Comparable<Hero> {
//~~~~~~


override fun compareTo(other: Hero): Int {
        if (this == other) return 0

        return this.name.compareTo(other.name) * -1
    }

}
```
- compareTo 메서드 내에 `* -1` 를 해주면 내림차순

### data class
- data class 를 쓰는 이유: 룰 통일
- kotlin 에서는 data class로 정의하면 copy() 를 통해 얕은 복사 제공
- equals(), hashCode(), toString() 메서드를 재정의 해준다.

### data 클래스가 깊은 복사가 아닌 얕은 복사를 제공하는 이유
- 일단 얕은 복사를 default 로 잡고 만약 추후 변경할 게 있다면 깊은 복사로 한다.
- 메모리 + 속도를 챙기기 위해
  - 복사를 한 순간 안변할거다. 라는 불변을 default로 생각한다.
  - 근데 만약 변한다면 그 때 깊은 복사를 처리.
