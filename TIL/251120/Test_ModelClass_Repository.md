# Test

## Test Double

- 테스트를 진행하기 어려운 경우에 테스트가 가능하도록 만들어주는 객체

## Mock 객체 활용

- 때때로 단위 테스트는 라이브 웹 서비스 또는 데이터베이스에서 데이터를 가져오는 클래스에 의존할 수 있다
    - 테스트 실행 속도가 느려진다
    - 예기치 않은 결과를 반환하면 통과 테스트가 실패하기 시작할 수 있다.
    - 가능한 모든 성공 및 실패 시나리오를 테스트하는 것은 어렵습니다.
    - 따라서 라이브 웹 서비스나 데이터베이스에 의존하는 대신 이러한 종속성을 Mocking할 수 있다.

## 테스트가 어려운 구조

- 의존성이 너무 높으면 테스트가 어렵다. : 다형성(인터페이스)을 활용해서 의존성을 끊어주는 게 좋다.

## 좋은 Unit Test의 6가지 조건

- Fast (빠르고)
- Reliable (믿을 수 있고)
- Independent (독립적인)
- Ease of Maintenance (유지 관리가 쉽고)
- Nearly compacted code (거의 압축적인 코드)
- Dependencies should be less (의존성이 적어야 한다)

# Model Class, Repository 개념

## Model Class의 책임과 역할

- 모델 객체 클래스의 속성에 대한 데이터를 조회할 수 있는 클래스
- 별도의 기능을 가지지 않는 순수한 클래스
- 데이터소스로 부터 받은 데이터를 앱에서 필요한 형태로 변환하여 앱 개발을 편리하게 해 주는 역할

### Model Class

- 비슷한 용어들
    - 도메인 모델
    - Entity
    - DTO
    - POJO
    - VO
    - 데이터 클래스 (4종 세트)
      equals(), hashCode(), toString(), copy()

## 모델링 방법

- 일반적으로 data class 로 정의하면 됨

### DDD (Domain Driven Design)

- Domain 의 정의
    - 유사한 업무의 집합
    - 특정 상황(주문, 결재, 로그인)이나 특정 객체(유저, 손님)가 중심이 될 수 있음

- 모델 클래스
    - 도메인을 data 클래스로 작성한 것

### ORM (Object-relational mapping)

- ORM 의 정의
    - 데이터 소스가 DB 인 경우 DB 와 모델간 상호 변환을 도와주는 기법
    - ORM은 DB 를 활용할 경우에 따로 살펴봐도 됨

## Repository 의 책임과 역할

- 데이터 접근의 진입점
- 데이터 접근에 대한 추상화 계층
- 데이터 소스 은닉
- 비즈니스 로직과 데이터 소스 사이의 중재자
- 데이터 매핑, 변환 담당

## Repository 패턴의 이점

- 데이터 접근 추상화
    - 데이터 소스 구현 세부사항 은닉
    - 일관된 인터페이스 제공
- 유지보수성 향상
    - 관심사 분리
    - 코드 재사용성
- 테스트 용이성
    - 데이터 소스 Mocking 가능
    - 단위 테스트 작성 용이
- 확장성
    - 새로운 데이터 소스 추가 용이
    - 기존 코드 수정 최소화
    - 인터페이스 기반 설계

*데이터 소스는 저장 매체와 직접적인 소통*
*레퍼지 토리는 데이터를 비즈니스 로직에 전달, 도메인 특화 기능을 제공*

## 도메인 특화 기능을 Repository 가 제공하는 경우의 장점

- 도메인 의도가 명확히 드러남
- 재사용 가능한 쿼리 로직
- 데이터 소스 구현과 분리된 비즈니스 요구사항 처리

## 주의할 점

- Repository는 어떤 데이터를 전달할지에 집중
- Repository는 직접적인 데이터 조작이 아닌 필요한 데이터를 골라내는 일을 할 것
- 저장 매체를 다루는 코드는 DataSource 에서 하도록
- 복잡한 비즈니스 로직은 더 상위 계층으로
