# Result 패턴
1. [코드 리뷰](#-코드-리뷰)
2. [Result 패턴](#result-패턴-1)
    - [Result 패턴이 필요한 상황](#result-패턴이-필요한-상황)
    - [Result 클래스 만드는 방법](#result-클래스-만드는-방법)
    - [어떻게 사용할까?](#어떻게-사용할까)
    - [Result 패턴 장점](#-result-패턴-장점)

## 📌 코드 리뷰

- `withContext(Dispatcher.IO)` 꼭 써주기!!
    - DataSource에서 꼭 써주기
    - 코틀린 환경은 상관없지만 (IO작업을 main 스레드에서 할 수 있음)
    - 안드로이드 환경에서는 무조건 IO 스레드에서 동작하도록 하지 않으면 제약이 걸려서 터짐 — 미리 설정해두면 터질일이 없다


- `if (response.status != HttpStatusCode.OK)` 대신 `if (response.status.*isSuccess*())` 써주면 200번대 상태 코드인지 검증해줄 수 있다


- 시험 버전의 API를 사용하면, `@OptIn(experimentalTime::class)` 같은 옵션을 추가하게 된다


- `takeIf` `let`
    - 코틀린에서 쓰면 있어보임


- `Iterable` 의 확장함수 `.map` 이 리턴하는 것은 list임

---

# Result 패턴

> 🥝 **패턴**: 여러 사람이 이렇게 해봤는데 좋더라~  
🥝 **Result 패턴**: Result<T> 만들어서 패턴에 따라 활용하겠다~


### Result 패턴이 필요한 상황

> 실패의 종류가 여러 가지일 때
>
- 서버에 데이터 요청시 예상되는 상황
    - 성공 (Success)
    - 실패 (Error, Failure) : 실패의 종류가 하나가 아님
        - 네트워크 연결이 안되어 있음
        - 네트워크 불안정으로 타임아웃 발생
        - 논리적으로 잘못된 값
        - 내가 판단했을 때 에러임 (실패 상황임)
        - 등등

### 에러 처리

- `try-catch`
    - 기본적인 예외는 try-catch 활용하여 처리
    - 런타임 에러만 처리 가능 (논리적인 오류나 예외 상황은 처리 불가)
- Result Pattern
    - 성공, 실패 처리시에 유용한 패턴
    - 내가 어떤 상황을 실패로 간주할건지 결정

  ➡️ 런타임 에러(exception)을 포함해서 논리적인 에러도 처리 가능


### Result Pattern

> 하나의 부모(result)한테 상속받아서 성공결과 / 실패결과로 반환되도록
>


### Result 클래스 만드는 방법

```kotlin
// 제네릭 읽기 전용 out (쓰기 전용 in)
sealed class Result<out D, out E> {
		data class Success<out D>(val data: D): Result<D, Nothing>()
		data class Error<out E>(val error: E): Result<Nothing, E>()
}
// D: 데이터
// E: 에러
```

> **Result 클래스는 성공시에는 데이터를, 실패시에는 에러 정보(ex: Exception, 문자열)를 담는 객체를 갖는다**
>
- Kotlin) `sealed class` 를 통해 `Result<T>` 를 정의하여 사용한다

  `sealed class` 클래스는 **타입 봉인 효과**를 가진다 (enum 비슷한 효과 + 다른 객체의 참조 가질 수 있음)

    - enum은 클래스가 아니라 재정의가 불가능해서 동등성 비교가 불가능
    - enum처럼 쓸건데, 동등성 비교가 가능한 클래스가 필요하다 (상위 호환)

- Unit VS Nothing
    - `Unit` : 정상 종료
    - `Nothing` : 비정상 종료 (예외 또는 무한루프)

- **Result 패턴 사용시 효과**
    - enum과 동일하게 when과 조합하여 모든 처리를 강제할 수 있다 (타입
    - 성공과 실패를 다 처리할 수 있다

### 어떻게 사용할까?

- **결과를 Result로 감싸기**
    - Repository에서는 Result<Todo> 이런식으로 한번 감싸서 result 반환하겠다

    ```kotlin
    // TodoRepositoryImpl
    // 성공시: List<Todo> 리턴
    // 실패시: NetworkError (enum class 정의해둔거) 리턴
    //				 String, Exception, ... 아무 형태나 가능
    suspend fun getTodos(): Result<List<Todo>, NetworkError> {
    		try {
    				return Result.Success(dataSource.getTodos()
    						.filter { it.id != null && it.userId != null }
    						.map { it.toModel() })
    		} catch (e: TimeoutException) {
    				return Result.Error(NetworkError.REQUEST_TIME_OUT)
    		} catch (e: Exception) {
    				return Result.Error(NetworkError.UNKNOWN)
    		}
    }
    ```


- repository에서 던진 성공/실패 처리하기
    - when으로 (모든 케이스의) 처리를 장제할 수 있음

    ```kotlin
    val result = repository.getTodos()
    
    when (result) {
    		is Result.Error ->
    				when (result.error) {
    						NetworkError.NO_CONNECTION -> TODO()
    						NetworkError.REQUEST_TIME_OUT -> TODO()
    						NetworkError.UNKNOWN -> TODO()
    				}
    		is Result.Success -> println(result.data)
    }
    ```


- `./core/` 에 만들자
    - 꼭 통신할 때만 사용하는게 아니고, 실패 케이스가 많은 어떤 경우든 사용 가능

### ✨ Result 패턴 장점

1. **타입 안정성**
    - 성공하면 D, 실패하면 E만 보이니까 Nullable 불필요 — 사용하기 편함

    ```kotlin
    fun getUser(): Result<User, NetworkError>
    ```

2. **에러 처리 강제성**
    - 컴파일러가 모든 케이스 처리를 강제함
    - 성공 / 실패 중에서 처리 안한 케이스가 있으면 컴파일러가 경고 / 에러

    ```kotlin
    when (result) {
    		is Result.Success -> showUser(result.data)
    		is Result.Error -> showError(result.error)
    }
    ```

3. **에러  타입의 명확한 문서화**
    - 시그니처만 봐도 어떤 에러가 오는지 알 수 있음
    - enum class로 만들면 어떤 에러가 있는지 명시할 수 있음
    - 굳이 복잡하게 sealed class로도 만들 수 있긴 함

4. **try - catch 남용 방지**
    - **DataSource**에서는 try-catch없이 터트리고 (원천데이터 가져만 와라. 일 너무 많이 하지 마라)
    - **Repository**에서 DataSource단에서 터지는 것을 try-catch에서 Result로 반환하여 처리함
    - when에서 Repository 메서드를 호출하여 에러 처리 하도록 하겠다

5. **비즈니스 로직과 에러 처리 분리**
    - repository에서 구체적인 에러처리 하지 않고 성공인지 실패인지만 보겠다 (에러 처리는 따로)
    - Domain / Repository 쪽) 비지니스 로직 + 매핑
    - UI 쪽) when에서 호출, 에러 → 메시지 / 상태 매핑

6. **Nullable 타입 사용 감소**
    - app단에서는 null 만날일이 없다 (실패해도 객체 따로 존재)

7. **테스트 용이성**


8. **패턴 매칭을 통한 가독성 향상**
    - when(객체) 값 / 타입체크 / … 체크할 수 있는게 여러가지임 (Kotlin에서)

### 정리

- Result 패턴은 성공과 실패를 명확하게 처리한다
    - UI단으로 가면 성공 / 실패 / 로딩중 으로 만들수도 있다
- sealed class는 서브타입을 봉인한다
- sealed class는 패턴 매칭을 활용하여 모든 서브타입에 대한 처리를 하기 용이하다
    - enum처럼 쓸 수 있다
- 예외 throw 없이 값으로 에러를 처리하며, 명확한 타입 구분을 지원한다
- Result 패턴은 when을 활용하여 모든 성공과 실패의 처리를 강제한다
- 앱의 규모에 따라 Result 클래스 버전1(성공의 제네렉만) 또는 버전2(에러가 담는 제네릭도 포함)를 선택

---

## Sealed Class

> `sealed class`를 쓰면 컴파일러에게 이렇게 알려주는 겁니다.  
**"야, 내 자식은 `Success`랑 `Error` 딱 이 두 놈밖에 없어. 다른 놈은 절대 없어. 맹세해."**
>

https://kotlinlang.org/docs/sealed-classes.html

---

## runCatching

- Kotlin이 만든 Result<T>를 반환함
    - Result<T>는 value class (참조 타입인 클래스를 값으로 취급하는 것)
    - enum 처럼 타입 매칭을 지원하지 않아서 잘 안씀…

- 내부에서 try-catch가 있어서 exception만 catch가 되는거라 제약이 있음
    - 논리적인 실패같은 경우는 사용할 수 없음
    - 생각보다 잘 새용하지 않음

---

`Result` 가 아니라 `Either`로 쓸 수도 있음 > `left` `right` (왼쪽이든 오른쪽이든 하나만)

ARROW라는 라이브러리에서 Either를 제공함