# 네트워크 통신
1. [코드 리뷰](#-코드-리뷰)
2. [네트워크 통신](#네트워크-통신-1)
    - [무상태성](#무상태성)
    - [TCP, UDP](#tcp-udp)
    - [요청 메서드](#요청-메서드)
    - [RESTful API](#restful-api)

## 📌 코드 리뷰

- 데이터 소스를 왜 인터페이스로 만들어서 인자로 받을까?
    - 테스트를 용이하게 하기 위해서


- 데이터가 이쁘면, repository에서 그대로 사용할 수 있다 (가공 없이)
    - 추상 클래스 같은걸로 추상화 할 수 있다 — 자바 spring (jpa)
    - 우리는 수동으로 하고 있으니 합칠 필요는 없다
    - 합치고 싶다면 제네릭을 넣어서 인터페이스 만들어서 할 수 있다


- `@SerialName("속성명")`  
  `val 필드명: 타입`
    - 이렇게 하면 JSON의 속성명과 필드명이 다르더라도 정상적으로 직렬화/역직렬화 가능


- mock 데이터를 /test가 아니라 /main에 둔다
    - 유닛 테스트만 할 것이 아니라, 실제 앱 테스트할 때 사용하려면


- `runBlocking` 블록 맨 아래에, 리턴이 있는 함수가 변수없이 호출되면 해당 블록의 리턴값으로 인식되므로, `Unit` 리턴 타입을 명시해줘야 한다

    ```kotlin
    @Test
    fun getUsersTop10ByUserName(): Unit = runBlocking {
    		userRepository.getUsers()
    }
    
    // 이러면 상관 없음
    @Test
    fun getUsersTop10ByUserName() = runBlocking {
    		val users = userRepository.getUsers()
    		
    		assertEquals(10, users.size)
    }
    ```


- 데이터 소스 / repository 이런식으로 나누는 것의 장점 — 왜 분리할까??
    - 테스트가 용이함 (input이 동일한 상황에서 로직만 확인하겠다)
    - 객체 지향 관점에서, 데이터를 직접 처리할 수 없도록 캡슐화/추상화 하는 것

    - 함께 개발을 할 때, 우선 인터페이스를 만들어두면 역할 분리가 좋다
    - 설계를 잘하는 높은 사람이 인터페이스를 만들어두면, 밑에서 개발하기 좋다
    - 서버와 클라이언트가 동시에 개발할 때, mock으로 이런 데이터가 올거다 가정하고 개발하면 된다


- `take()` 확장함수
    - 인자의 크기가 list의 크기보다 클 때, 내부적으로 처리되어 있어서 예외처리할 필요가 없다


- 아키택처 == 폴더 구조를 보는 것
    - 과제도 폴더 구조에 맞게 작성해보자


- mix-in
    - 데이터소스 구현체와 mock데이터 소스 구현체의 비지니스 로직이 같을 때,  
      인터페이스에서 구현을 진행할 수 있다

    - 추상 클래스와 뭐가 다르냐?  
      상속 기회가 1번밖에 없으나, 인터페이스는 기회가 많다


- mock 데이터를 무작위로 만들지 않고 원본 데이터를 mock 데이터로 들고와서 테스트한다
    - 뭐가 다르냐? 데이터 소스가 저장 매체에 접근해서 데이터를 들고오는 과정이 필요없다

---

## 네트워크 통신

> 결국에 앱만들어서 하는 것: 서버와 통신 (HTTP 요청)

- UNI
    - UNL — 웹에서 사용
    - URN — 모바일에서 사용

- HTTP 개념
    - HyperText Transfer Protocol
        - Protocol: 전송 규약
    - text로 인코딩해서 나중에 디코딩해서 사용

- 계층
    - Telnet: 터미널에서 서버와 접속할 수 있음
    - FTP (File Transfer Protocol) : 터미널에서 파일 전송 가능
    - DHCP : IP 주소 분배 (공유기)
    - SMTP : 이메일 보낼 때
    - DNS :

### 무상태성

- HTTP는 상태 비저장 프로토콜 == 무상태성 == 불변이다
-

- 응답없음
    - Android 10초
    - iOS 60초
    - Web은 무제한

### TCP, UDP

- **TCP** — 격투 게임(두 사람이 동일한 화면을 봐야한다. 싱크가 맞아야 한다)
    - 신뢰성 있는 **연결지향성** 앱에서 사용
      (이메일, 파일 전송, 웹브라우저 — HTTP 쓰지만, 내부적으로는 TCP도…)
    - Stateful 프로토콜 (상태가 있음. 이어서 전송 가능)
    - 텍스트가아닌 바이너리 데이터 전송 (컴퓨터에 친화적이고, 비용이 싸고 빠름)
    - 식별자 필요 (바이너리 데이터니까, 어디까지가 데이터고 사용해라 알려줘야 함)

- TCP/IP
    - IP 기반으로
    - IP는 하난데 포트 번호는 여러개라서 여러 통로에서 통신 가능
    - TCP/IP에 대한 rfc 파일
    - https://datatracker.ietf.org/doc/html/rfc2616

- **UDP** — mmoRPG (한사람이 끊긴다고 나머지가 끊길 필요는 없음. 싱크가 안맞는 경우)
    - 신속한 테이터 전송이나 손실 가능성이 있는 상황에 주로 사용
    - **비연결형** 프로토콜
    - 데이터 전달 보장이 안되어 신뢰성 낮음
    - 멀티캐스팅 및 브로드캐싕

- 앱에서는 HTTP를 사용
    - 연결지향으로 가면 안됨
    - 요청 던지고, 받는 형식

---

### 요청 메서드

> 웹에서 HTTP 통신할 때 요청의 형태를 정의하는 키워드

https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods

- 상황에맞게 사용하는 것이 관례
    - `GET` : 데이터 요청
    - `POST` : 데이터가 포함된 요청
    - `DELETE` : 삭제
    - `PUT` : 전부 업데이트 (새로 쓰기)
    - `PATCH` : 일부 업데이트 (일부만 고쳐 쓰기)

| **메서드** | **역할 (목적)** | **특징 및 비유** | **데이터 전송 위치** |
| --- | --- | --- | --- |
| **GET** | 조회 (Read) | 신문 읽기. 데이터를 가져오기만 함. | URL (`?` 뒤에) |
| **POST** | 생성 (Create) | 편지 부치기. 새로운 데이터를 등록함. | Body (보이지 않음) |
| **PUT** | 수정 (Update) | 파일 덮어쓰기. 데이터를 통째로 교체함. | Body |
| **PATCH** | 일부 수정 | 문서 교정하기. 데이터의 일부만 변경함. | Body |
| **DELETE** | 삭제 (Delete) | 문서 파쇄하기. 데이터를 지움. | URL 또는 Body |
1. **GET**
    - 일반적으로 웹 브라우저가 서버에 웹 페이즈를 요청할 때 사용
    - 읽기 요청
    - **body를 포함할 수 없음**
    - `?` 와 `&` 문자를 사용하는 **쿼리 파라미터**를 추가할 수 있다
        - `?` : **쿼리 스트링의 시작**
          URL의 경로와 파라미터 구분하는 기준점, URL 전체에서 **단 한 번**만 등장
        - `&` : **파라미터 간의 구분자**
        - `key=value` 형태

   https://jsonplaceholder.typicode.com/comments?postId=1&name=hello

   ➡️ comments 데이터를 보내줘. postId가 1이고, name이 hello인 것만

2. **POST**
    - 웹브라우저로 테스트 불가
    - 클라이언트에서 서버로 데이터가 포함된 요청을 보낼 때 사용
        - 로그인, 주문 요청 등
        - 주소에 포함되면 문제가 될 것 같은 것을 body에 심어서 보냄
    - 쿼리 파미터 뿐만 아니라 body로 데이터 전송
3. DELETE, PUT, PATCH — 웹브라우저로 테스트 불가 == body

- 주소에 포함되면 문제가 될 것 같은 것 — `POST` 의 body에다가 심어서 보냄

- **HTTP 요청 헤더**

  https://developer.mozilla.org/ko/docs/Web/HTTP/Headers

    - 요청 정보를 파악하는데 도움이 되는 다른 여러 정보를 포함할 수 있ㅇ음
    - JSON 파일을 주고 받을 때 Content-Type에 application/json으로 명시

    ```
    ### POST 요청
    POST https://jsonplaceholder.typicode.com/posts/
    Content-Type: application/json
    
    {
      "userId": 5,
      "title": "hello",
      "body": "World"
    }
    ```


- **상태 코드**

  https://developer.mozilla.org/en-US/docs/Web/HTTP/Status

    - 서버측에서 보내고 싶은거 보낼 것
    - 내(클라이언트)가 잘못 쓴거면 400번대 상태 코드가 올것이다
    - 서버 잘못이면 500번대

```
Informational responses (100 – 199)
Successful responses (200 – 299)
Redirection messages (300 – 399)
Client error responses (400 – 499)
Server error responses (500 – 599)
```

- 쿠키는 앞으로 없앨 것
    - 해킹에 취약함

### RESTful API

> REST (REpresentational State Transfer) 조건을 만족한다 = RESTful  
: 분산 시스템을 위한 소프트웨어 아키텍처의 한 형태

- 서버와 클라이언트가 메시지를 주고받을 때 가장 많이 사용하는 통신 규격 (암묵적인 룰)
- 관례라서 안지켜도 할 말이 없음. 클라이언트단에서 방어적으로 잘 받아야 함
- 요청 주소(URL)과 메서드(GET, POST 등), JSON 규격을 이용하여 API를 정의
- 오늘날 가장 범용적으로 사용

```
GET	/posts ➡️ 모든 게시글 목록을 조회
GET	/posts/1 ➡️ ID가 1인 게시글을 조회
GET	/posts/1/comments ➡️ ID가 1인 게시글에 달린 댓글 목록 조회
GET	/comments?postId=1 ➡️ postId가 1인 댓글들을 조회

POST	/posts ➡️ 새 게시글 생성
PUT	/posts/1 ➡️ ID 1인 모든 게시글, 전체 수정
PATCH	/posts/1 ➡️ ID 1인 모든 게시글, 일부 속성 수정
DELETE	/posts/1 ➡️ ID 1인 게시글 삭제
```

```kotlin
// post의 첫번째 인자는 URL
// 두번째 인자는 요청을 빌드하는 Lambda
public suspend inline fun HttpClient.post(
    urlString: String,
    block: HttpRequestBuilder.() -> Unit = {}
): HttpResponse = post {
    url(urlString)
    block()
}
```

- HttpClient를 mocking 할 수 있음 (가짜 서버 만들어서 테스트 가능)

---

- 왜 response 모델 객체를 만들어줘야할까?
    - repository는 비지니스 로직만 처리해야하는데, ktor같은 라이브러리가 추가됨 — 의존성 문제

      즉, 추상화된 DataSource 쪽에 대해서 알아야하는 상황이 올 수 있음

    - 특정 라이브러리가 제공하는 타입(HttpResponse)같은 것을 내걸로(내 앱에서 사용할 응답 객체를) 만들면 라이브러리에 대한 의존성을 없앨 수 있음
        - 이후에 라이브러리 바뀌더라도 DataSource만 수정해주면 됨

- 특정한 요청을 주면 exception 내도록 함
    - 네트워크 에러
    - 존재하지 않은 ID
    - 짜고 치기