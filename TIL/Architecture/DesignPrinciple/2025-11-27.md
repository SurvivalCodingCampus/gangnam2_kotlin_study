# 설계 원칙, 디자인 패턴
1. [코드 리뷰](#-코드-리뷰)
2. [설계 원칙](#설계-원칙)
   - [응집도는 높게, 결합도는 낮게](#응집도는-높게-결합도는-낮게)
   - [설계 원칙 6가지 (레거시)](#설계-원칙-6가지-레거시)
   - [설계 원칙 SOLID](#설계-원칙-solid)
3. [디자인 패턴](#디자인-패턴)
    - [소프트웨어 디자인 패턴](#소프트웨어-디자인-패턴)
    - [아키택처 디자인 패턴](#아키택처-디자인-패턴)


## 📌 코드 리뷰

- Result 패턴 : Repository에 적용
    - Exception 처리가 어려우니, 에러도 정상 처리가 되도록 감싸는 것

- DataSource에서 Result 사용 가능 but. Repository도 해줘야해서 복잡
    - Response있으면  상태코드로 예외 처리 가능해서 편함
    - Result는 App쪽 가장 앞단에서만 써주면 됨

- 모델를 직렬화하면, JSON의 key과 달라질 가능성이 있어서

  `@Serializable` 을 할 수 없도록 하는게 나을 수도 있다 (고민 가능성 없애기)

    - 직렬화 대상이 아님 — 서버와 맞닿아있는 부분만 직렬화 됨
    - 모델 `.toDTO` 로 DTO로 변환하고 이걸 직렬화해서 서버와 통신하게 됨

- Kotlin 기존 내장 `Lint` 가 빡세지 않음
    - 원래 프로그램임
    - detekt 라이브러리 — Lint 프로젝트 단위 검사해줌

- 테스트할 때, 꼭 실제 로직처럼 Exception을 낼 필요는 없다
    - 테스트 코드에서 mocking해서 그냥 `throw` 해주고 이걸 제대로 처리하는지만 확인해주면 됨

---

## 설계 원칙

- **응집도 (Cohesion)** : 특정 기능이 다 하나에 모여있다
    - 여러 모듈로 나눌수록 응집도가 높아진다

- **결합도 (Coupling)** : 모듈이 다른 모듈에 의존하는 정도의 척도
    - 인터페이스로 접

### 응집도는 높게, 결합도는 낮게

- DataSource가 원천 데이터를 들고오는 일만 하자 — **응집도가 높음**
    - DataSource가 데이터 처리(Repository의 역할)까지하면 응집도가 낮음

- 인터페이스를 통해서 접근하면, 특정 클래스에 의존하지 않게 된다 — **결합도가 낮음**
    - 클래스 내부에서 특정 클래스를 생성하여 사용하면 직접 의존하게 된다 — 결합도가 높음

### 설계 원칙 6가지 (레거시)

> 좋은 코드를 위해 의식해야 하는 6가지 코드 작성 윈칙

- **DRY** (Don’t Repeat Yourself) : 같은 것을 몇번씩 반복하지 말라
    - 중복 코드가 있다면 메소드로 분리해라

- **PIE** (Program Intently and Expressively) : 명확하고 표현혁 있게 기술하자
    - 이름 잘 짓자
    - 매직 넘버에 이름을 붙이자

- **SRP** (Single Responsibility Principle) : 단일 책임 원칙
    - 한 클래스는 하나의 책임만 가진다
    - 클래스는 하나의 기능이나 책임만을 가져야하며, 그 책임이 변경될 때 해당 클래스만 수정하면 된다
    - 기능이 많은 거대 클래스는 테스트도 어렵고 유지보수도 어렵다
    - **외부 객체는 생성자로 주입 받아라**

- **OCP** (Open Closed Principle) : 개방 폐쇄 원칙
    - 확장에 대해서는 열려있고, 변경에 대해서는 닫혀있다 — 원본 코드를 수정없이 새로운 기능을 추가할 수 있다

      (확장은 자유롭고, 의존 부분의 변경은 힘들다)

    - **애초에 기능 확장이 되도록 인터페이스를 활용하자 (다형성)**
    - Monster로 해두면 Slime말고 다른 몬스터들 추가하면 자동으로 기능이 늘어남 (다른 몬스터도 때릴 수 있음)

- **SDP** (Stable Dependencies Principle) : 안전한 것에 의존하라
    - String 같은건 import 없이도 쓸수 있어서 안전함 — 외부 객체여도 클래스에서 생성함
    - 안전한 건 다른 클래스여도 의존할 수 있다
    - 인터페이스를 활용하는 게 좋긴 하다

      **가장 좋은 것은 특정 클래스가 아니라 인터페이스에 의존하는 것이다**

    - 라이브러리를 직접 사용하는 대신 감싸는 인터페이스를 만들고, 의존성 주입을 받아라

- **ADP** (Acyclic Dependencies Principle) : 의존성 비순환 원칙
    - 사이클이 있으면 메모리 누수가 발생함

      GC는 참조가 있으면 메모리 해제가 안되기 때문에 쌓이다가 언젠간 터짐


### 설계 원칙 SOLID

| 두문자 | 약어   | 개념                                                                                                                                                                                                                          |
| --- |------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| S | SRP  | 단일 책임 원칙 (Single responsibility principle)<br>”한 클래스는 하나의 책임만 가져야 한다.”                                                                                                                                                      |
| O | OCP  | 개방-폐쇄 원칙 (Open/closed principle)<br>”소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.”                                                                                                                                                 |
| L | LSP  | 리스코프 치환 원칙 (Liskov substitution principle)<br>“프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.” [계약에 의한 설계](https://ko.wikipedia.org/wiki/%EA%B3%84%EC%95%BD%EC%97%90_%EC%9D%98%ED%95%9C_%EC%84%A4%EA%B3%84)를 참고하라. |
| I | ISP  | 인터페이스 분리 원칙 (Interface segregation principle)<br>“특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.”                                                                                                                               |
| D | DIP  | 의존관계 역전 원칙 (Dependency inversion principle)<br>프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.”<br>의존성 주입은 이 원칙을 따르는 방법 중 하나다. |

- SRP
    - 외부 객체는 생성자로 주입 받아라
- OCP
    - 원본 수정없이 기능 확장 되도록 인터페이스로 작성하자
- ISP
    - 인터페이스를 많이많이 쪼개서 만들어라
    - Bionic만 구현하지 말고, Attackable, Moveable, Healable처럼 기능처럼 쪼개라

- **LSP**
    - is-a 를 잘 맞춰라
    - 현실세계가 계약이다. 이 것을 깨뜨리지 마라
    - ex) 사전 is a 전자사전은 현실 세계에 맞지 않으므로 원칙에 위배됨

- **DIP**
    - 인터페이스 잘 쓴다
    - 인터페이스에 의존해야지 특정 클래스에 의존하면 안된다
    - 원래 화살표가 한쪽 방향인데, 인테페이스에 의존하면 인터페이스에 화살표가 몰림 — 의존성 역전이라고 함
    - Repository → DataSource ← MockDataSourceImpl, RemoteDataSourceImpl, …

---

## 디자인 패턴

### 소프트웨어 디자인 패턴

- 싱글톤도 디자인 패턴의 일종
- StringBuilder — 문자열을 만드는 패턴
- Iterator 패턴 — List, …

- Decorator
    - 감싸는 것

- Command
    - execute() 호출할 수 있는데, 실행되는건 다 다르다
    - undo / redo 구현할 때 사용

### 아키택처 디자인 패턴

> 프로젝트 전체 구조(Architecture)에 대한 패턴들

- MVC (Model View Control)
- MVVM
    - 화면에서 할 일 / 유저가 접근 가능한 일
      인터페이스로 만들어서 처리