## 문자열 조작 (String)

### 문자열 불변성 (Immutability)

> Kotlin의 String은 Java의 String을 사용 <br/>
> → 불변 객체(immutable object)로 한 번 생성된 문자열은 절대 수정되지 않음

```kotlin
var s = "Hello"
s.replace("H", "J") // 새 "Jello" 객체 반환, s는 여전히 "Hello"
s = s.replace("H", "J") // 이제 s가 "Jello"를 참조
```

- 문자열 조작 메서드는 항상 새로운 String 객체 반환
    - 만약 재할당 하지 않으면 원래 것은 바뀌지 않음

### String Pool

> 동일한 리터럴 문자열은 String Pool에 저장되고 재사용됨

```kotlin
val s1 = "hello"
val s2 = "hello"
println(s1 === s2) // true → 같은 객체 (String Pool)
```

- 런타임 생성시에는 다르므로 주의
    ```kotlin
    val s3 = "hel" + getLo()
    println(s1 === s3) // false → 새 객체 생성
    ```

### 문자열 결합

| 방식             | 동작 시점 | Pool 사용 | 결과          | 예시      |
|----------------|-------|---------|-------------|---------|
| `"a" + "b"`    | 컴파일 시 | ✅       | `"ab"`      | 공통 리터럴  |
| `"a" + getB()` | 런타임 시 | ❌       | 새 String 생성 | 힙에 새 객체 |

- 내부적으로 런타임에서는 StringBuilder 가 사용되어 문자열을 임시로 이어 붙임
    - 불변성이 유지되므로 기존 문자열은 그대로 두고 새 객체를 만듦.

### 문자열 결합 성능

> 문자열을 반복해서 덧붙일 때 + 대신 StringBuilder / StringBuffer 사용 권장

- `+` 는 매번 새로운 String 객체를 만들어 비효율적
- StringBuilder 는 가변 버퍼를 사용 → 한 번의 객체 생성으로 처리
    ```kotlin
    val sb = StringBuilder()
    repeat(1000) {
        sb.append("Hello")
    }
    val result = sb.toString() // 한 번에 String 생성
    ```
    - 결론적으로 반복 문자열 조작 시 StringBuilder가 훨씬 빠름

### 문자열 비교

| 비교 방식 | 의미             | 예시                    | 결과      |
|-------|----------------|-----------------------|---------|
| `==`  | 내용 비교 (equals) | `"a" == "a"`          | ✅ true  |
| `===` | 참조 비교 (같은 객체?) | `"a" === String("a")` | ❌ false |

### 객체 생성 차이 비교

| 코드                              | 설명                   | Pool 사용 | 결과   |
|---------------------------------|----------------------|---------|------|
| `"hello"`                       | 리터럴, Pool에 저장        | ✅       | 재사용  |
| `"hel" + "lo"`                  | 컴파일 시 결합 → `"hello"` | ✅       | 재사용  |
| `"hel" + getLo()`               | 런타임 결합 → 새 객체        | ❌       | 새 객체 |
| `String("hello".toCharArray())` | 명시적 객체 생성            | ❌       | 새 객체 |
