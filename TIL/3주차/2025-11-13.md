# 정규식 (Regular Expression), 에러(Error)와 예외(Exception), 파일 조작, 직렬화(Serialization)

## 1️⃣ 정규식

문자열에서 **특정 패턴을 찾거나 검사**하기 위한 표현식.

### 대표 메타 문자

1. `.`
    - 임의의 한 문자 (줄바꿈 제외).

2. `*`
    - 앞 패턴을 **0회 이상 반복**
    - 예: `a*` → `""`, `"a"`, `"aa"` …

3. `{ }` (반복 횟수 지정)
    - `{n}`: 앞 문자가 n회 반복
    - `{n,}`: 앞 문자가 n회 이상 반복
    - `{n,m}`: 앞 문자가 n회 이상 m회 이하 반복

4. `[ ]` (문자 클래스)
    - 대괄호 안에 있는 문자 중 **어느 한 문자**
    - 예: `[abc]` → `a`, `b`, `c` 중 하나.

5. `[-]` (범위)
    - 문자 범위를 지정
    - 예: `[A-Z]`, `[0-9]`

6. `^`, `$`
    - `^`: 문자열 **시작**
    - `$`: 문자열 **끝**

---

## 2️⃣ 에러(Error)와 예외(Exception)

### 에러 종류

| 구분    | syntax error  | runtime error          | logic error        |
|-------|---------------|------------------------|--------------------|
| 원인    | 코드 형식적 오류     | 실행 중 예상 외 상태 발생        | 처리 절차는 맞지만 결과가 잘못됨 |
| 발견 시점 | 컴파일 시         | 실행 도중 프로그램이 강제 종료될 때   | 실행 결과가 기대와 다를 때    |
| 해결 방법 | 컴파일러 지시 따라 수정 | 예외 원인 분석 후 코드/예외 처리 수정 | 원인 분석 후 로직 수정      |

---

## 예외(Exception)

### 개념

- 실행 중 발생할 수 있는 **예상 외 상황**을 표현하는 객체.
- API에는 다양한 예외 클래스가 준비되어 있고, 필요하면 상속을 통해 **사용자 정의 예외**를 만들 수 있음.

```kotlin
try {
    // 예외가 발생할 수 있는 코드
} catch (e: Exception) {
    // 예외 정보 처리
    println("예외 발생: ${e.message}")
}
```

### 주요 예외 처리 요소

- `try`
    - 예외가 발생할 가능성이 있는 코드를 감싸는 블록.
- `catch`
    - 발생한 예외를 받아서 처리하는 블록.
- `finally`
    - 예외 발생 여부와 상관없이 마지막에 반드시 실행할 코드(자원 정리 등).
- `throw`
    - 코드에서 **의도적으로 예외를 발생**시킬 때 사용.

### 특정 예외 캐치

- 하나의 `try`에 대해 **여러 개의 `catch`** 를 둘 수 있고,
  보통 **구체적인 예외 타입을 먼저**, 마지막에 `Exception` 같은 상위 타입을 둔다.

```kotlin
try {
    someErrorProneFunction()
} catch (e: IllegalArgumentException) {
    println("IllegalArgumentException: ${e.message}")
} catch (e: NumberFormatException) {
    println("NumberFormatException: ${e.message}")
} catch (e: Exception) {
    e.printStackTrace()
}
```

---

## 3️⃣ 파일 조작

- `writeText(...)`
    - 파일을 새로 만들거나 기존 내용을 **덮어씀**.
- `appendText(...)`
    - 기존 파일의 **끝에 내용 추가**.
- `readText()`
    - 파일 전체를 하나의 문자열로 읽음.
- `readLines()`
    - 파일을 **줄 단위 리스트(List<String>)** 로 읽음.

---

## 4️⃣ 데이터 형식

### CSV (Comma-Separated Values)

- 데이터를 **콤마(,)** 로 구분하여 나열하는 단순한 텍스트 형식.

### XML

- `<tag>` 형식의 태그로 데이터를 표현.
- 태그의 중첩 구조로 **계층(포함) 관계**를 나타낼 수 있음.
- 처리 시 DOM Parser, SAX Parser 등 **전용 파서**가 필요.

### JSON (JavaScript Object Notation)

- 네트워크 통신에서 가장 널리 쓰이는 데이터 형식 중 하나.
- XML보다 구조가 단순하고 용량이 적은 편.
- 구문 요소
    - `{ }`: 객체
    - `[ ]`: 리스트(배열)
    - `"key": value`: 키-값 쌍

---

## 5️⃣ 직렬화(Serialization)

### 개념

- **객체나 데이터 구조의 상태를 저장·전송하기 쉬운 포맷으로 변환**하는 과정.
    - 예: 메모리 상의 객체 → 파일, 바이트 스트림, JSON 문자열 등.
- 직렬화된 데이터를 다시 객체로 되돌리는 것을 **역직렬화(Deserialization)** 라고 함.

```kotlin
class User(var name: String, var email: String) {

    // 직렬화: 객체 -> JSON 문자열
    fun toJson(): String = """
        {
            "name": "$name",
            "email": "$email"
        }
    """.trimIndent()

    companion object {
        // 역직렬화: JSON 문자열 -> 객체 (간단한 예시용)
        fun fromJson(json: String): User {
            val name = json.substringAfter("\"name\": \"").substringBefore("\"")
            val email = json.substringAfter("\"email\": \"").substringBefore("\"")
            return User(name, email)
        }
    }
}
```

### 특징

- 객체를 파일에 저장해 두었다가 나중에 읽어 **동일한 상태의 객체**로 재구성 가능.
- 네트워크 통신에서는 보통
    - 직렬화: **클래스 → JSON**
    - 역직렬화: **JSON → 클래스**
- 클래스 안에 다른 클래스 타입의 필드가 있다면,  
  그 필드 타입도 **함께 직렬화 가능**해야 함.
- JSON 직렬화 라이브러리 사용 시:
    - 필드명과 JSON 키가 같다면,  
      `@Serializable`어노테이션만으로 자동 직렬화/역직렬화 구성 가능.

---

## 과제 리뷰

> ### 연습문제 1
> 
> 작성한 코드를 수정하여, try-catch() 문을 사용하여 예외처리를 하시오.
> 예외처리에는 다음의 처리를 수행하시오.
> 
> 예외가 발생하면 0으로 처리

```kotlin
val numString = "10.5"

val num: Int = try {
    numString.toInt()
} catch (e: Exception) {
    0
}
```

---

> ### 연습문제 2
> 
> 다음 요구사항을 만족하는 DefaultFileOperations 클래스를 작성하시오
>
> 1) 두 개의 File 객체 (원본 파일, 대상 파일)을 인자로 받아 파일을 복사하는 메서드 구현
> 2) 파일 조작의 기본 순서에 따라 복사 로직을 처리할 것
> 3) 원본 파일이 존재하지 않거나 복사 과정에서 오류가 발생할 경우 적절한 예외 처리 포함

```kotlin
override fun copyFile(source: File, destination: File) {
    val text = source.readText()
    destination.writeText(text)
}
```

- `readText()`를 사용하여 소스파일의 내용을 복사한다.
- `writeText()`를 사용하여 대상파일에 붙여넣는다.

```kotlin
override fun copyFileSafely(source: File, destination: File): Boolean {
    try {
        copyFile(source, destination)
        return true
    } catch (e: Exception) {
        println("${e.message}")
        return false
    }
}
```

- 파일의 내용을 복사하는 함수인 `copyFile()`을 `try catch{...}`문으로 검사하고 통과하면 **true**, `Exception`이 발생하면 **false**를 반환한다.

---

> ### 연습문제 3
> 
> 총무부 리더 ‘홍길동(41세)’의 인스턴스를 생성하고 직렬화하여 company.txt 파일에 저장하는 프로그램을 작성하시오.
> 직렬화를 위해 위의 2개 클래스를 일부 수정하시오.

```kotlin
class Employee(
    var name: String,
    var age: Int
) {
    fun toJson() = """
        {
            "name": "$name",
            "age": $age
        }
    """.trimIndent()
}

class Department(
    var name: String,
    var leader: Employee
) {
    fun toJson() = """
        {
            "name": "$name",
            "leader": "${leader.toJson()}"
        }
    """.trimIndent()
}
```

- `Employee`의 필드를 JSON 문자열로 직렬화하고, `Department`는 자신의 `name`과 `leader.toJson()`으로 만든 JSON을 문자열 형태로 포함해 직렬화한다.