# 제네릭 (Generics), 열거형 (enum), 문자열

---

## 제네릭 (Generics)

- 사용하는 시점에 원하는 타입으로 정의해 **타입 안전**(type-safe)을 확보한다.
- 제네릭이 없으면
    1) 런타임 에러가 나기 쉽고
    2) IDE/컴파일러가 미리 에러를 잡지 못한다.
- 공변성/반공변성
    - `<out T>`: 읽기 전용(생산자). 하위 타입을 상위 타입으로 대체 가능(공변).
    - `<in T>`: 쓰기 전용(소비자). 상위 타입을 하위 타입으로 대체 가능(반공변).
    - 표기가 없으면 상황에 따라 읽기/쓰기 모두 가능하지만 의도를 명시하는 편이 안전하다.

```kotlin
class Pocket<E> {
    private var _data: E? = null

    fun put(data: E) {
        _data = data
    }

    fun get(): E? = _data
}
```

---

## 열거형 (enum)

- 미리 **정의된 값만** 가질 수 있는 타입.
- 각 항목의 타입은 해당 enum 타입 자체이며, `name`/`ordinal`을 가진다.
- `when`과 함께 쓰면 **모든 경우 처리**(exhaustive)를 강제하여 휴먼 에러를 줄인다.

```kotlin
enum class AuthState {
    AUTHENTICATED, UNAUTHENTICATED, UNKNOWN
}

fun something(authState: AuthState) {
    when (authState) {
        AuthState.AUTHENTICATED   -> println("Authenticated")
        AuthState.UNAUTHENTICATED -> println("Unauthenticated")
        AuthState.UNKNOWN         -> println("unknown")
    }
}
```

---

## 문자열(String) 처리

- 기본 연산: 결합 `+`, 보간 `$`, `substring`, `replace`, `split`, `uppercase/lowercase`,  
  `indexOf/lastIndexOf`, `contains`, `startsWith/endsWith`, `length`, `isEmpty/isBlank`, `trim`.
- `String`은 **불변**이므로 반복 결합 시 **StringBuilder** 권장  
  (빠르지만 스레드 비안전, 스레드 안전이 필요하면 StringBuffer).
- 동일성 vs 동등성: `==`(내용) / `===`(참조).  
  리터럴은 보통 String pool에 intern되어 참조가 재사용될 수 있다.

```kotlin
// StringBuilder 사용
val sb = StringBuilder("Kotlin")
repeat(3) { sb.append("hi") }
val result = sb.toString()
```

---

## Accessor / Mutator

- **Accessor(게터)**: 내부 값을 읽음
- **Mutator(세터)**: 내부 값을 변경

---

## 과제 리뷰

> ### 연습문제 1
>
> 다음 조건을 만족하는 금고인 StrongBox 클래스를 정의하시오.
>
> 1) 금고 클래스에 담는 인스턴스의 타입은 미정
> 2) 금고에는 1개의 인스턴스를 담을 수 있음
> 3) put() 메서드로 인스턴스를 저장하고 get() 메서드로 인스턴스를 얻을 있음
> 4) get() 으로 얻을 때는 별도의 타입 캐스팅을 사용하지 않아도 됨

```kotlin
class StrongBox<E>{
    var instance: E? = null

    fun put(thing: E){
        instance = thing
    }

    fun get(): E? = instance
}
```

---

> ### 연습문제 2
>
> 연습문제 1에서 작성한 StrongBox 클래스에 열쇠의 종류를 나타내는 열거형 KeyType을 정의하고,
> 다음 내용을 반영하여 StrongBox 클래스를 수정하시오.
>
> 열쇠의 종류를 나타내는 필드 추가
> 열쇠의 종류를 받는 생성자
>
> 단, 열쇠의 종류는 다음 4종류로 한정한다. 각 열쇠 종류는 시도횟수의 한도가 정해져 있다.
>
> 1) padlock    (1,024회)
> 2) button      (10,000회)
> 3) dial             (30,000회)
> 4) finger       (1,000,000회)
>
> 금고에서 get() 메서드를 호출할 때 마다 사용횟수를 카운트하고 각 열쇠의 사용횟수에 도달하기 전에는 null을 리턴한다.
>
> 예를 들어, 쿠팡에서 이 금고를 주문할 때 키 타입을 정해서 주문을 한다.
> 금고에 넣고 싶은 것을 넣을 수 있다.
> 키 타입에 따라 정해진 횟수만큼은 열리지 않는다.
> 횟수에 도달하면 잠금이 해제되어 열린다.

```kotlin
enum class KeyType(val attempts: Int) {
    PADLOCK(1024),
    BUTTON(10000),
    DIAL(30000),
    FINGER(1000000)
}
```

- 횟수(attempts)를 가지고있는 키 타입을 `enum`타입으로 저장한다.

```kotlin
class StrongBox<E>(
    private val keyType: KeyType
) {
    var count: Int = 0
    var instance: E? = null

    fun put(thing: E): Boolean {
        if (instance != null){
            return false
        }

        instance = thing
        count = 0
        return true
    }

    fun get(): E? {
        count += 1

        if (instance == null) {
            return null
        }

        if (count == keyType.attempts) {
            val value = instance
            instance = null
            return value
        }

        return null
    }
}
```

- `get()`을 호출할 때마다 1씩 증가하는 프로퍼티 `count`를 선언한다.
- `put()`은 물건이 들어간 후 열릴 때까지 다른 물건을 넣을 수 없으므로 `Boolean` 타입을 반환한다.
- `get()` 호출 시 `count`가 `keyType`의 횟수와 같다면 물건을 반환한다.

---

> ### 연습문제 3
>
> i 번째 글자가 모음인지 알려주는 isVowel() 메서드를 완성하시오
> 영어에서의 모음은 a, e, i, o, u 다섯가지이다

```kotlin
class Word(var word: String) {
    private val vowelString = "a e i o u"

    fun isVowel(i: Int): Boolean {
        if (i < 0 || i > word.length - 1) {
            throw IndexOutOfBoundsException("범위를 벗어났습니다.")
        }

        return vowelString.contains(word.substring(i, i + 1))
    }
```

- 모음을 저장하는 문자열 `vowelString` 프로퍼티 생성
- 확장 함수 `contains()`를 사용해 i번째 글자가 `vowelString`에 포함되는지 확인한다.
- i가 0 미만이거나 `word`의 마지막 인덱스를 초과하면 `IndexOutOfBoundsException`을 던진다.

---

> ### 연습문제 4
>
> i 번째 글자가 자음인지 알려주는 isConsonant() 함수를 수정하시오

```kotlin
    fun isConsonant(i: Int): Boolean {
        if (i < 0 || i > word.length - 1) {
            throw IndexOutOfBoundsException("범위를 벗어났습니다.")
        }

        return !vowelString.contains(word.substring(i, i + 1))
    }
```

- 기본적으로 `isVowel()`과 동일하지만 !를 적용해 자음 여부를 검사한다.