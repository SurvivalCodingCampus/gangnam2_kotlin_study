# 상속

- 이전에 만든 클래스와 닮았지만 일부 클래스를 만들 필요가 있는 경우

## 복사 붙여넣기의 문제점

- 추가, 수정에 시간이 걸린다.
- 소스의 파악이나 관리가 어려워진다.
- 인간이 하니까 실수가 날 수 있다.

상속을 활용하여 해결해보자

## 코틀린은 기본 값이 상속 금지이다.
- final(상속불가)로 선언된 것과 같다.

```kotlin
open class Hero() {} 
```

- open 키워드를 붙여야 상속이 가능하다.
- 상속 = 계승의 느낌. 모든 것을 물려주겠다.

```kotlin
class SuperHero(name: String, hp: Int) : Hero(name, hp) {}
```

- 부모 클래스의 생성자 호출이 필수다. 그렇지 않으면 부모 부분이 초기화 되지 않아 컴파일 에러 발생

### 다중상속은 코틀린에서 불가능하다.

## 오버라이드

- 부모의 기능을 자식이 재정의
- 오버라이드도 막혀있다.

```kotlin
open class Hero() {
    open fun run() {
        println("Hero의 run")
    }
}
```

- open 키워드를 붙여야 사용 가능하다.

```kotlin
class SuperHero() {
    // 기능 재정의
    override fun run() {
        println("다시 쓴 run")
    }
}
```

## 상속과 생성자 init 초기화 블럭

- init: 객체 생성시 자동으로 실행되는 초기화 구역
  즉, 생성자의 파라미터들이 값으로 들어오고 난 후, 그걸 가지고 무언가 추가적인 초기 작업을 하고 싶을 때 사용한다.
- 부모를 먼저 호출한 후 자식이 나온다.

## 올바른 상속

- is-a 원칙을 잘 지키자 ( 슈퍼히어로는 히어로의 한 종류이다. )

## 잘못된 상속

- 현실세계와의 모순 ( 개념적으로 잘못된 상속 ) 

ex) 비행기 is a 새
- 다형성을 이용할 수 없게 된다.

## 구체화와 일반화의 관계
- 자식클래스 일수록 구체화되고, 부모클래스 일수록 추상적인 것으로 일반화 된다.

## 총 정리
### 1. 상속의 기초
- open 키워드를 사용하여 기존 클래스를 기초로 하는 새로운 클래스를 정의 할 수 있다
- 부모 클래스의 멤버는 자동적으로 자식 클래스에 상속되므로, 자식 클래스에는 추가 된 부분만 기술 하면 된다
- 부모 클래스에 있는 메소드를, 자식 클래스에서 재작성 할 경우 이것을 오버라이드 한다고 한다
- 올바른 상속이란 “자식 클래스 is-a 부모 클래스"
- 상속에는 “추상적, 구체적" 관계에 있다는 것을 정의하는 역할도 있음

### 2. 인스턴스
- 인스턴스는 내부에 부모클래스의 인스턴스를 가지는 다중구조를 가진다
- 보다 외측의 인스턴스에 속하는 메소드가 우선적으로 동작한다
- 외측의 인스턴스에 속하는 메소드는 super 을 사용하여 내측 인스턴스의 멤버에 접근할 수 있다

### 3. 생성자 동작
- 다중구조의 인스턴스가 생성되는데, 자동적으로 가장 외측 인스턴스의 생성자가 호출 됨
- 모든 생성자는, “부모 인스턴스의 생성자"를 호출 할 필요가 있다
