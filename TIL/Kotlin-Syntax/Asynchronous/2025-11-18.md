# 비동기 프로그래밍

### 동기 VS 비동기

- **동기 Synchronous** 프로그래밍:
- 비동기 Asynchronous :  
앱 개발에서는 비동기 프로그래밍을 해야 함 (ex. 데이터 불러오면서 화면 출력)

### 동시성 VS 병렬성

- **동시성 Concurrency**: 여러 작업을 번갈아가면서 처리하는 것
    - 여러 작업이 **논리적**으로 동시에 실행되는 것처럼 보이는 개념
    - 시분할 방식으로 여러 스레드를 활용해 동시성을 구현할 수 있음
    - CPU 하나로 여러 작업이 가능한 것 처럼 보이는 것
- **병렬성 Parallelism**: 여러 작업을 실제로 동시에 처리하는 것
    - 여러 작업이 **물리적**으로 동시에 실행되는 개념
    - 멀티코어 환경에서 실제로 여러 스레드가 병렬로 실행될 수 있음
    - CPU 여러개로 각각 스레드를 실행하면 병렬적으로 실행할 수 있음

- 스레드는 안쓸 수 있으면 안써야한다
    - 어쩔 수 없는 경우에만 사용하고, 테스트를 엄밀히 해야한다

- 콜백 지옥이 일어날 수 있음

## 코루틴 Coroutine

> 스레드, 콜백 최대한 안쓰고 논리적인 접근으로 비동기 처리를 하겠다
>
- 모던 안드로이드 개발을 위한 라이브러리: Jetpack
  - Jetpack Compose UI는 모두 비동기 처리함

- 코루틴의 기본 동작: **순차 실행**
  - 콜백 기반 코드를 순차 코드로 변환할 수 있다
  - 순차 코드는 읽기 쉽고 에러 처리가 편하다
  - Java 코드로는 순서를 맞출 방법이 없다
    누가 먼저 끝날지 예측할 수 없으면, 끝나고 함께 처리해야 할때 너무 어렵다
  - 성능을 버리고 안전하고 예측가능하게 만든 것

- 일반적인 멀티태스킹과 코루틴
  - 일반적으로는 하나의 코루틴이 특정한 스레드에서 동작
  - `suspend` 와 `resume` 을 통해 스레드를 양보한다
  - 코루틴은 비동기식이며 스레드를 차단하지 않는다
  - 코루틴은 일시 중단 함수를 사용하여 비동기 코드를 순차적으로 만든다

- 코루틴의 장점
  - 휴먼 에러에 의한 **메모리 누수**나 데드락에서 안전하다
  - 가능한 이유:
  - 다른 언어의 async, await와 같은 키워드가 제공되지 않는다
  - 대신 일시 중단 함수를 활용한 안전한 비동기 처리에 중점을 둔다

### 코루틴 스코프

> **구조화된 동시성**: 코루틴의 수명은 코루틴 스코프 내에서 결정됨
이러한 규칙은 메모리 누수나 손실을 방지함
>
- 코루틴은 스코프에 의존적이다
  - 코루틴은 코루틴 스코프 안에서만 시작할 수 있다

- **코루틴 빌더**
  - 코루틴 코드를 실행할 수 있도록 코루틴 스코프를 만들어 준다
  - `launch { }` — 스레드를 블록하지 않는 코루틴 필더
    - 반환값: `Job`
    - 용도: 결과가 필요없는 비동기 작업
  - `async { }` (키워드가 아니고 함수임)
    - 반환값: `Deferred<T>`
    - 용도: 결과가 필요한 비동기 작업
    - 이후 `await()` 를 통해 결과값에 접근 가능 (특수케이스. 잘 사용하지 않음)
  - `runBlocking { }` — 스레드를 블록하는 스레드 빌더
    - 반환값: T
    - 용도: 코루틴과 일반 코드 연결
    - 안드로이드에서는 사용하지 않음. Unit Test에서 사용

- `Job`
  - 인터페이스
  - 비동기 작업을 가장 추상화한 것
  - 나중에 코루틴을 취소할 때 사용할 수 있음

### Dispatcher

> 코루틴이 어떤 스케줄러에 의해 수행될지를 지정할 수 있다
>
- Default
  - 백그라운드 스레드
  - 코어 수에 비례해서 스레드를 만든다. 연산용
  - CPU에 부하를 줄 만한 처리 (로컬에서 List 정렬 등)
- Main
  - 메인 스레드에 연결되는 디스패처
- IO
  - 백그라운드 스레드
  - Input/Output 조작용
  - 상대적으로 많은 스레드를 만드는 디스패처 (DB 통신 / Http 통신)
- Unconfied
  - 특정 스레드를 한정하지 않음. 공식 문서에서 보통 사용하지 않는다고 명시되어 있음

- 각 코루틴 빌더마다 디스패처를 지정할 수 있음
  - `launch(Dispatchers.IO) { }`

- `withContext()`
  - dispatcher를 마음대로 전환할 수 있음