# 제네릭, 열거형, 문자열 조작

1. [코드 리뷰](#코드-리뷰)
2. [제네릭](#제네릭-generic)
3. [열거형](#열거형-enum)
4. [문자열 조작](#문자열-조작)

### 코드 리뷰

- `java.time` 패키지
  - [LocalDateTime | kotlinx-datetime](https://kotlinlang.org/api/kotlinx-datetime/kotlinx-datetime/kotlinx.datetime/-local-date-time/-local-date-time.html)
  - LocalDateTime.toLocalDate로 타입 변경 가능
- LocalDateTime
  - LocalDateTime의 인터페이스를 타고 들어가면 Comparable이 있음
  - 불변 클래스 타입이라서 깊은 복사를 할 필요는 없다 — 일반 값으로 취급함
    - 어떻게 불변타입인걸 알았냐?? 까고 들어가면 모든 필드에 `final` 이 붙어있음
- 불변 객체
  - 컴퓨팅 파워로 휴먼 에러를 없애자 (성능은 버려)
  - 변하지 않는데 복사하는 것은 의미가 없음
  - 모두가 참조해도 괜찮음
  - class를 안변하게 만들면 됨 — `val`, 기초타입, 문자열, 내부 객체도 불변이면 됨
    - 불변 클래스를 data class로 만들면, equals toString hasCode를 재정의해주고  
    copy도 있으니까 얕은 복사만 사용하면 됨


- java에서 `copy()` 대신  `Clonealbe` 를 구현해서 `clone` 을 사용함
  - 마커 인터페이스이고, 강제성이 없음

---

# 제네릭, 열거형

> 1. 다형성으로 런타임에 타입이 결정되는 것은 불안하다 (타입 안전성)  
> 2. 컴파일러가 믿어버려서, 컴파일 에러로 확인할 수 없다


## 제네릭 Generic

> 사용하는 시점에 타입을 원하는 형태로 정의할 수 있음  
타입 안전성 type safety 효과

[Generics: in, out, where | Kotlin](https://kotlinlang.org/docs/generics.html)

```text
List<E> class
Map<K, V> class
```

- **Use-site variance: type projections**
  - 읽기 전용 (Covariance, 공변성)  
  `class Pocket<out T>`  
  `List<? extends T>` — Java (와일드카드)

  - 쓰기 전용 (Contravariance, 반공변성)  
  `class Pocket<in T>`  
  `List<? super T>`

  - 둘 다 가능 (Invariance, 무변성)  
  `class Pocket<T>`


## 열거형 ENUM

> 정해둔 값만 넣어둘 수 있는 타입

[Enum classes | Kotlin](https://kotlinlang.org/docs/enum-classes.html)

```kotlin
enum class Color {
    RED, YELLOW, GREEN, BLUE
}
```

- enum class에서 가장 기본적인 사용은 type-safe enum을 구현하는 것이다
  - 각 열거형 상수 (enum constant)는 객체이고, `쉼표 ,` 로 구분됨

```kotlin
enum class Color(val rgb: Int) {
    RED(0xFF0000),    // => Color(0xFF0000) 생성자 호출
    GREEN(0x00FF00),
    BLUE(0x0000FF)
}
// Color.RED.rgb로 접근 가능
```

- Since each enum is an instance of the enum class, it can be initialized  
  각 enum은 열거형 클래스의 인스턴스이므로, 초기화될 수 있음

### Java 디컴파일 결과

```java
public enum KeyType {
    PADLOCK(1024),
    BUTTON(10000),
    DIAL(30000),
    FINGER(1000000);

    private final int keyNumber;

    private static final EnumEntries $ENTRIES = EnumEntriesKt.enumEntries($VALUES);

    private KeyType(int keyNumber) {
        this.keyNumber = keyNumber;
    }

    public final int getKeyNumber() {
        return this.keyNumber;
    }

    @NotNull
    public static EnumEntries getEntries() {
        return $ENTRIES;
    }

    private static final KeyType[] $values() {
        KeyType[] var0 = new KeyType[]{PADLOCK, BUTTON, DIAL, FINGER};
        return var0;
    }
}
```

```sql
enum class KeyType(val keyNumber: Int)
 ├── property: keyNumber (private final int)
 ├── constructor(int keyNumber)
 ├── constants (static final instances)
 │    ├─ PADLOCK = new KeyType("PADLOCK", 0, 1024)
 │    ├─ BUTTON  = new KeyType("BUTTON", 1, 10000)
 │    ├─ DIAL    = new KeyType("DIAL", 2, 30000)
 │    └─ FINGER  = new KeyType("FINGER", 3, 1000000)
 ├── getKeyNumber()
 ├── $ENTRIES (EnumEntries<KeyType>)
 ├── $values() helper
 └── values()/valueOf() (Enum 기본 제공)
```

1. public enum KeyType
    - 자바 `enum`으로 변환됨. 즉 `java.lang.Enum<KeyType>`을 상속
    - 각 상수는 `KeyType` 클래스의 **싱글턴 인스턴스**로 존재함
2. PADLOCK(1024), BUTTON(10000), …
    - An enum constant may be followed by arguments, which are passed to the constructor of the enum when the constant is created during class initialization as described later in this section. The constructor to be invoked is chosen using the normal rules of overload resolution ([§15.12.2](https://docs.oracle.com/javase/specs/jls/se9/html/jls-15.html#jls-15.12.2))
      열거형 상수 뒤에는 인수가 올 수 있으며, 이 인수는 이 섹션의 뒷부분에서 설명하는 클래스 초기화 과정에서 상수가 생성될 때 열거형의 생성자로 전달됩니다. 호출될 생성자는 일반적인 오버로드 해결 규칙( [§15.12.2](https://docs.oracle.com/javase/specs/jls/se9/html/jls-15.html#jls-15.12.2) )에 따라 선택됩니다
    - [The Java® Language Specification | Enum Types — 8.9](https://docs.oracle.com/javase/specs/jls/se9/html/?utm_source=chatgpt.com)

---
# 문자열 조작

- 문자열 내부 `$` 는 + 연산으로 치환되어 처리됨
- `split` 의 결과는 list형태로 반환됨

### 문자열 결합 방법

> 문자열 + 문자열은, 기존 문자열이 수정되는 것이 아니라  
해당 문자열이 새롭게 생성된다  
즉, String은 불변(immutable) — 안전함


1. **+ 연산**
2. **String interpolation**
3. **StringBuilder** — 스레드에 안전하지 않지만 빠름 / 동시에 접근하려하면 터짐
4. **StringBuffer** — 스레드에 안전함 thread-safe (자바에는 써야하지만, 코틀리는 코루틴 쓸거니까)

### StringBuilder

[StringBuilder | Kotlin](https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.text/-string-builder/)

- 문자열을 수정하는 개념
- toString() 시점에 한번에 수정할거라 빠름
- 문자열을 여러번 결합하는 경우에 사용하면 성능이 좋다

### String pool

- **컴파일 타임 상수**는 미리 들어감
- 런타임에 생성되는 문자열은 heap에 할당됨

- “hel” + “lo” 는 컴파일 시점에 “hello”라는 것을 알 수 있음 ⇒ string pool 에 들어감
- 컴파일 시점에서 함수가 어떤 값을 리턴할지 알 수 없음

### Accessor, Mutator

- accessor : 원본은 변화가 없고, 변경된 값을 리턴만 해주는거 (= getter)
- mutator : 보통은 리턴이 없고, 원본을 변경한다