# 디버깅, 람다식과 함수
1. [코드 리뷰](#-코드-리뷰)
2. [디버깅](#디버깅-debugging)
3. [람다식과 함수](#람다식과-함수)
   - [함수](#함수)
   - [람다식](#람다식)
   - [함수형 프로그래밍](#함수형-프로그래밍)

## 📌 코드 리뷰

- 파일 인코딩 타입
    - JVM 인코딩, 디코딩 형식 같이 하는게 좋음 (`UTF-8` 로)

- Gson
    - 구글에서 만든 라이브러리, Java에서 사용
    - 리플렉션으로 동작
    - 비용이 많이 들고 느림

- `try-catch` 도 표현식임

```kotlin
val numString = "10.5"

val num: Int = try {
		numString.toInt()
} catch (e: NumberFormatException) {
    0   // 반환값 
}

println(num)
```

- 터지지 않는 것을 확인하는 assert문이 존재

- 직렬화
    - encodeToString을 하면 재귀를 돌면서 내부에 존재하는 객체도 직렬화를 해줌
    - 직렬화는 json만 얘기하는게 아님

- 해당 예외를 전졌을때 안터진다 라는 것을 assert문으로 확인

- 직렬화 테스트
    - JSON 형식으로 잘 직렬화되었는지
    - 파일에 저장되었는지

- scope 함수


---

## 디버깅 Debugging

> 소프트웨어의 오류를 식별하고 수정하는 과정

- 디버깅 기술
    - 로깅
    - 브레이크포인트
    - 디버거
    - 스택 추적

## 람다식과 함수

https://kotlinlang.org/docs/lambdas.html

**1급 객체**

> first class object, first class citizen

- 변수에 대입 가능한 객체를 1급 객체라고 한다
- ex: 값, 인스턴스, 함수
- 코틀린 함수는 1급객체 [first-class](https://en.wikipedia.org/wiki/First-class_function)임
    - 즉, 변수와 데이터 구조에 함수를 저장할 수 있고
    - 다른 고차 함수에 인수로 전달되거나 반환될 수 있음

**함수 VS 메서드**

- 메서드는 클래스에 속하고 클래스를 조작하기 위한 일종의 함수
- 메서드는 이름이 있지만, 함수에게 이름은 중요하지 않다

### 함수

> 입력이 동일할 때 항상 동일한 출력을 함


#### 함수의 표현 방법

- **일반 함수**

    ```kotlin
    fun sum(a: Int, b: Int): Int {
    		return a + b
    }
    ```


- **Expression Body** 또는 **single expression function**

    ```kotlin
    fun multiply(a: Int, b: Int): Int = a * b
    fun multiply(a: Int, b: Int) = a * b    // 타입 추론
    ```


- 람다식 (람다 표현식, **lambda expression**)
    - 단일 매개변수 람다 :  람다의 매개변수가 하나인 경우 매개변수를 생략하고 `it`을 사용할 수 있다

    ```kotlin
    val sumLambda: (Int, Int) -> Int = { a, b -> a + b }
    val square: (Int) -> Int = { it * it }
    ```

    - **후행 람다**: 함수의 마지막 인자가 람다인 경우, 함수 호출 소괄호 밖에 람다를 작성할 수 있다

    ```kotlin
    // 예시: repeat
    
    @kotlin.internal.InlineOnly
    // 원래 Int형과 람다식 2개의 인자를 받는 함수
    // 마지막 인자가 람다라서 밖으로 뺄 수 있음
    public inline fun repeat(times: Int, action: (Int) -> Unit) {
        contract { callsInPlace(action) }
    
        for (index in 0 until times) {
            action(index)
        }
    }
    
    repeat(3, { println(it) }) 
    
    repeat(3) {
    		println(it)
    }
    ```


#### function reference

- 함수를 일급객체로 다룰 수 있게 값으로 취급

```kotlin
fun myFunction(i: Int) {
    println(i)
}

fun main() {
		val list = listOf(1, 2, 3)
    list.forEach(::myFunction)
}
```

#### 함수가 하나만 있는 인터페이스는 람다로 변경 가능
> 무명클래스 → 람다식 → 후행 람다 → 각종 생략

```kotlin
// 인터페이스를 런타임에 객체로 작성 (무명 클래스)
button.setOnClickListener(object : View.OnClickListener {
		override fun onClick(v: View?) {
				TODO()
		}
})

// Java의 SAM(Single Abstract Method)인터페이스는 람다식으로 대체 가능
button.setOnClickListener({ view -> TODO() })

// 마지막 인수가 람다식이면 소괄호 생략 가능
button.setOnClickListener { view -> TODO() }
button.setOnClickListener { _ -> TODO() } // 미사용 파라미터 _로 치환
button.setOnClickListener { TODO() } // 미사용 파라미터, 화살표 생략
```

### 람다식

- `Consumer`
    - 메서드 하나를 가짐

- 디폴트 메서드: 인터페이스에 기능을 가진 메서드가 존재할 수 있음  
  ㄴ 객체지향 확장해서 mix in

### 함수형 프로그래밍

#### 고계 함수 higher-order function

> = 함수를 다루는 함수 = 함수를 파라미터로 받는 함수

**Kotlin의 대표적인 고계 함수**

- `filter` : 조건 필터링
- `map` : 변환
- `forEach` : 전체 순회
- `reduce` : 하나씩 줄이기
- `fold` : 하나씩 접기
- `any` : 있는지 없는지