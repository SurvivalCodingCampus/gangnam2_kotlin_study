# 다형성 Polymorphism

> 어떤 것을 이렇게도 부를 수 있고 저렇게도 부를 수 있는 것  
손흥민은 남자이고, 축구선수이다


- scope 함수

- **인터페이스로 선언된 변수의 실제 타입은 런타임에 결정됨**
  - **해당 변수로 메서드를 호출하면, 실제 구현체의 메서드가 호출됨**
- 구체적인 것을 위 계층에서 몰라도 된다는 장점이 있음
  - 예를들어, val a: Student 에게 어떤 메서드를 시켜야했다면
  - val a: Person 에게 시켜서 누가 할지 특정시키지 않아도 됨

```kotlin
class Wizard(
    name: String,
    hp: Int,
    var wand: Wand? = null,
    var mp: Int = 100,
) : Character(name, hp) {

    override fun attack(slime: Slime) {
        println("$name 이 $slime 을 공격했다")
        slime.hp -= 20
    }
		
    fun fireball(slime: Slime) {
        println("$name 이 파이볼을 쏘았다")
        slime.hp -= 50
        mp -= 20
    }
}

fun main() {
    val wizard = Wizard(name = "해리포터", hp = 50)
    val character: Character = wizard
    val slime = Slime("A")

    character.attack(slime)
    character.fireball(slime) // 컴파일 에러
}
```

- character의 fireball()이 불가능한 이유?
  - 컴파일러 입장에서 해당 변수는 Character로만 보임
  - Character에만 있는 것들만 접근이 가능한데, Character에는 fireball()이 없으므로 접근 불가

```kotlin
abstract class Monster {
    open fun run() = println("뚜벅뚜벅")
}

class Slime(val suffix: String) : Monster() {
    var hp = 50
    override fun run() = println("슬라임 $suffix 가 도망쳤다")
}

fun main() {
    val slime = Slime("A")
    val monster: Monster = Slime("B")
    slime.run()
    monster.run()
// 결과: 슬라임, 슬라임
}
```

- 실제로 어떤 인스턴스인가가 중요함
  - 다형성은 같은 대상은 어떤 별칭으로 부를지를 고민하는 것 — 실제 존재하는 것은 변하지 않음
  - 컴파일러가 봤을때는 선언된 것으로 보지만, 런타임 시점에서는 실제 구현체가 호출됨

```kotlin
val book2: Thing = Book(
    name = "생존코딩",
    price = 100,
    color = "파랑",
    isbn = "123123",
    weight = 100.0,
)

val book3: Book = book2 as Book
```

- 더 상위 개념은 그냥 들어가지 않음
  - `as`로  강제 타입 캐스팅을 해줄 수 있음 — but 위험함

```kotlin
if (book2 is Book) {
    val book: Book = book2
}
```

- `is` 로 타입 체크를 하고나면, 캐스팅 된 것으로 인식함 — 스마트 캐스팅

**메서드 오버로딩 overloading**

> 여러 클래스를 파라미터로 지정하고싶을때, 각 메서드를 오버로딩해서 작성하지 않고
상위 클래스를 파라미터로 지정해서 하나로 사용 가능
