# 인스턴스 기본 조작
[📌 학습 목표](#학습-목표)  
1. [Object 클래스](#1-object-클래스)  
  - Object 클래스의 대표 메서드
  - Set, Map의 동작 원리  

2. [정렬]()  
  - 확장 함수
  - Comparable 인터페이스
  - Comparator 인터페이스  

3. [얕은 복사 VS 깊은 복사]() 

[💬 게임 설계 과제 리뷰]()

## 학습 목표
```text
📌 내가 작성한 클래스의 인스턴스를 제대로 활용하고 싶다!!! (컬렉션, 정렬, 복사)
기초 타입(primitive type)처럼 값 기반으로 동작하도록 해서 일관성을 유지 -- 휴먼 에러 줄이기
```


### 학습 동기

```kotlin
// primitive type - 숫자
val a = 10
val b = 10
println(a === b)
// 출력: true

val intList = mutableListOf<Int>()
intList.add(a)
println(intList.size)    // 출력: 1
intList.remove(b)
println(intList.size)    // 출력: 0
```

```kotlin
// 문자열
val c = "10"
val d = "10"
println(c === d)
// 출력: true

val strList = mutableListOf<String>()
strList.add(c)
println(strList.size)    // 출력: 1
strList.remove(d)
println(strList.size)    // 출력: 0
```

**Kotlin의 모든 타입은 객체이고, 문자열은 특히 String 클래스임을 확실히 알고 있다**

**그런데  Int형은 메모리상에서 같은 상수 리터럴을 가리키고 있다고 쳐도, 문자열은 주소값을 비교해야하는 것 아닌가? 결과가 왜 저렇게 나올까???**

**그리고 내 클래스의 인스턴스도 저렇게 활용하고 싶다!**

### 1. `===` 비교가 true인 이유

#### **1-1) `Int`의 경우: 박싱과 캐싱 (Boxing & Caching)**

- Kotlin의 `Int`는 실제로는 JVM의 `int`(primitive)이지만, 객체로 동작할 때는 `Integer`로 자동 박싱(auto-boxing)됨
- JVM은 **-128 ~ 127 범위의 Integer 값**을 캐싱함
  - 그래서 이 범위 안의 숫자에 접근할 때, 동일한 `Integer` 객체를 재사용

- dentity equality for arguments of types 'Int' and 'Int' is deprecated.
  Condition 'a === b' is always true
  - `Int` 타입끼리의 `===` 비교는 더 이상 권장되지 않는다 (deprecated)  
    그 비교 결과는 항상 true로 판단된다

  - 왜냐하면, Kotlin의 `Int`는 Java 코드에서 필요할때만 `Integer` 객체로 박싱되기 때문
      즉, 위의 코드를 Java 코드로 디컴파일해보면 `int` 형인 것을 확인할 수 있는데
      이처럼 객체가 아닌 경우에 참조 비교를 하고있으니 항상 true를 반환한다는 것


#### **1-2) `String`의 경우: 문자열 상수 풀(String Pool)**

- JVM은 문자열을 효율적으로 관리하기 위해 **String Pool (intern pool)** 을 사용
- 즉, “10” 같은 **리터럴 문자열은 상수 풀에 한 번만 저장**되고,  
  같은 리터럴을 다시 쓰면 같은 참조를 재사용


### 2. 리스트에서 remove()가 가능한 이유

- `MutableList.remove(element)`는 내부적으로 `equals()` 비교  
  즉, `===` (참조 비교)가 아니라 `==` (값 비교)이기 때문에  
  다른 참조라도 문자열 내용이 같다면 제거됨

---
## 1. Object 클래스

> Class `Object` is **the root of the class hierarchy**.  
Every class has `Object` as a superclass.  
All objects, including arrays, implement the methods of this class.


- Java에서 모든 `class`는 `Object` 클래스를 상속받음 (생략됨)
    - 즉 모든 클래스는 Object의 메서드와 프로퍼티를 가짐
    - Object 타입 변수에는 모든 인스턴스를 대입 가능
- Kotlin에서는 `Any`지만 기본은 `Object`를 따름

### **Object 클래스의 대표 메서드**

```kotlin
override fun toString(): String {
    return "Hero(name='$name', hp=$hp)"
}
```

#### 1. `toString()`

> 문자열 표현을 얻을 때 사용

- 오버라이드해서 사용 가능 — 디버깅할때나.. 필요한대로
- 원래는 `package.클래스명@해시값` 을 반환함
- IDLE에서 generate > toString()

- println(h1)은 h1.toString()이 생략된 것임


```kotlin
override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (javaClass != other?.javaClass) return false

    other as Hero

    if (hp != other.hp) return false
    if (name != other.name) return false

    return true
}
```

#### 2. `equals()`

> 객체의 동등함을 비교할 때 사용 (Kotlin에서는 `==` 사용)

- 오버라이드하면 나만의 동등성 규칙을 정의할 수 있음
- 원래 Java는 `return (this==object)`로 되어있음; 실제 주소가 같아야 true

  ```kotlin
  h1 == h2   // 자바의 equals()
  h1 === h2  // 실제 주소값 비교, 자바의 ==
  ```


- 모든 필드값이 같을때 같은 객체로 판단하도록 재정의하면,  
  list같은 컬렉션에서 add, remove할 때 자동으로 같은 객체로 판단해서 연산 진행

- list에서는 같은 객체로 판단해서 remove했는데 set에서는 그렇지 않음 — 왜???
  - `Set`과 `Map`에서는 내부적으로 hashcode를 가지고 동일성 판단을 해서 그러함 (hash set)
  - 이것도 맞춰줄 수 있음 — hashCode() 재정의로!

```kotlin
override fun hashCode(): Int {
    var result = hp
    result = 31 * result + name.hashCode()
    return result
}
```

#### ⭐ 3. `hashCode()` 

> 해시값을 주소같은 느낌으로 바라봐도 무방함  
   재정의 하게되면 unique하지 않아짐 — 주소값으로 취급하면 안됨

- **`hashCode()` 알고리즘 — 내부적으로 31을 곱하는 이유**
  - 해시 코드를 도출하기 위해선, 모든 필드의 값를 하나의 정수로 압축해야함
  - 필드의 순서를 반영하기 위해 가중치(=31)을 곱함  
  `hash = hp * 31^(n-1) + name.hashCode() * 31^(n-2) + ...`  
  다항식 해시(polynomial rolling hash) 형태로 구성됨

  - 31을 사용하는 이유
  1. 소수 prime number: 곱할 때 패턴이 덜 생김
  2. 2⁵ - 1 구조: 비트 연산으로 빠르게 계산 가능
     (`31*x == (32-1)*x == (x<<5) - x`)
  3. Java 전통 (Effective Java): `hash = 31 * hash + field` 는 Joshua Bloch가 제안한 표준 패턴
  4. 충돌 최소화: 실제 충돌률이 낮은 것으로 경험적으로 검증됨


- `hashCode()` 와 `equals()` 를 항상 세트로 재정의해야 함 — 왜???  
  **hash 기반 컬렉션의 동작 원리** 때문에  
  `HashSet`, `HashMap` 같은 컬렉션은 내부적으로 **해시 버킷(Hash Bucket)** 구조를 사용함
1. 인스턴스에서 `hashCode()` 로 해시값을 반환 받고
2. 해시값을 버킷 인덱스로 변환하고
3. 그 버킷 안에서 `equals()` 로 같은 객체인지 확인함

- HashMap 내부 구조

> **해시 테이블(Hash Table) :** 버킷들의 배열 구조  
> **해시 버킷(Hash Bucket) :** 같은 버킷 인덱스(= 해시코드를 해시 함수에 넣은 결과)를 공유하는 엔트리들의 집합

```text
HashMap<K, V> {
    table: Array<Node<K, V>?>   // 해시 테이블 (배열)
}

Node<K, V> {
    key: K
    value: V
    hash: Int
    next: Node<K, V>?           // 같은 버킷 내 연결 리스트 (또는 트리)
}
```

```text
            HashMap (해시 테이블)
┌────────────────────────────────────────┐
│ index 0 │  index 1  │  index 2  │ ... │ index 15 │
│   ↓     │     ↓     │     ↓     │     │     ↓     │
│  null   │   NodeA   │   null    │ ... │  NodeB    │
└────────────────────────────────────────┘
               ↓                 ↓
          [Bucket 1]        [Bucket 15]
          NodeA(key1,val1) → NodeA2(key9,val9)
                             ↑ 같은 해시코드 충돌 시 연결
```

- 삽입 동작 순서
1. `key.hashCode()` 호출
2. 해시 함수를 통해 버킷 인덱스 계산
3. 해당 버킷에 노드가 없으면) 새 노드 삽입
4. 해당 버킷에 노드가 있으면) `equals()`로 같은 키인지 비교
   - 같으면 `value` 업데이트
   - 다르면 연결 리스트로 추가(or *Red-Black* 트리로 변환) — 충돌 상황


#### Set, Map의 동작 원리
- 왜 `Set` 과 `Map` 은 요소 검색할 때 hashCode를 사용하여 빠름 — 왜??
  - `List` 는 equals를 사용하여 필드 개수만큼 == 연산이 필요한데
  - hashCode를 사용하면 한번만 연산하면되니까 훨씬 빠름 O(1)
  - 근데 해시값이 같은데 다른 객체일 경우도 있어서 해시값이 같으면 equals()까지 확인함


## 2. 정렬

```kotlin
val names = listOf("김", "이", "최")
val sortedNames = names.sorted()    // 확장 함수
```

- `.sorted`는 원본 list를 변경하지 않음
    - primitive type은 정렬가능
    - 내가 만든 class의 인스턴스들은 정렬 불가

```kotlin
fun String.myFunction(): Int {
    return 10
}

fun main() {
    println("111".myFunction())
}
```

- **확장 함수:**
  - 클래스, 인터페이스, …에 기능을 추가하는 것
  - 기능 확정을 위해서는 상속을 해야하지만 확장 함수를 선언해서도 가능하다

#### 1. `Comparable 인터페이스`

- `Comparable` 를 구현한 애들은 `sorted`를 해주겠다 (String, Int …)
  - 0 리턴) other랑 같으면
  - 음수 리턴) other보다 작으면
  - 양수 리턴) other보다 크면
  - 이렇게 `Comparable`를 구현하면 내가 만든 클래스에서도 `.sort` 사용 가능
- `compareTo` 의 리턴값을 잘 조정하면 내림차순/오름차순을 설정해줄 수 있음

#### ⭐ 2. `Comparator 인터페이스`

> Java, … 뭐 다 가지고 있는 인터페이스

- `.sortedWith()`
- `.sortedWith { }`
- `.sortdBy { }`


## 3. 얕은 복사 VS 깊은 복사

- 변경할 때 copy해서 다시 만들어서 쓸거라서 얕은 복사가 디폴트
  - 즉, 변하지 않을 것을 가정하고 복사를 함

---
### 게임 설계 과제

- 예외상황이 발생할 수 있으므로, 최하단에서 인터페이스를 많이 구현하는 것이 좋다

- Bottom-up이 훨씬 쉽다
    - 인터페이스를 활용하면 설계 가능하다
    - 세부 객체의 속성을 인터페이스로 전부 뽑고, 공통된 속성들을 묶어주면 된다
    - 마커 인터페이스: 메서드 설계 없이 속성만 붙인 것 (역할 부여)
    - 최상단에 Unit 같은걸로 다 묶는게 제일 안좋다…
