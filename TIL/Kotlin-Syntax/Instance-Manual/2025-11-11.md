# 인스턴스 기본 조작
[📌 학습 목표](#학습-목표)  
[1. Object 클래스]()  
[2. 정렬]()  
[3. 얕은 복사 VS 깊은 복사]()  
[💬 게임 설계 과제 리뷰]()

## 학습 목표

    📌 내가 작성한 클래스의 인스턴스를 제대로 활용하고 싶다!!! (컬렉션, 정렬, 복사)


### 학습 동기

```kotlin
// primitive type - 숫자
val a = 10
val b = 10
println(a === b)
// 출력: true

val intList = mutableListOf<Int>()
intList.add(a)
println(intList.size)    // 출력: 1
intList.remove(b)
println(intList.size)    // 출력: 0
```

```kotlin
// 문자열
val c = "10"
val d = "10"
println(c === d)
// 출력: true

val strList = mutableListOf<String>()
strList.add(c)
println(strList.size)    // 출력: 1
strList.remove(d)
println(strList.size)    // 출력: 0
```

**Kotlin의 모든 타입은 객체이고, 문자열은 특히 String 클래스임을 확실히 알고 있다**

**그런데  Int형은 메모리상에서 같은 상수 리터럴을 가리키고 있다고 쳐도, 문자열은 주소값을 비교해야하는 것 아닌가? 결과가 왜 저렇게 나올까???**

**그리고 내 클래스의 인스턴스도 저렇게 활용하고 싶다!**

### 1. `===` 비교가 true인 이유

**1-1) `Int`의 경우: 박싱과 캐싱 (Boxing & Caching)**

- Kotlin의 `Int`는 실제로는 JVM의 `int`(primitive)이지만, 객체로 동작할 때는 `Integer`로 자동 박싱(auto-boxing)됨
- JVM은 **-128 ~ 127 범위의 Integer 값**을 캐싱함
    - 그래서 이 범위 안의 숫자에 접근할 때, 동일한 `Integer` 객체를 재사용

- dentity equality for arguments of types 'Int' and 'Int' is deprecated.
  Condition 'a === b' is always true
    - `Int` 타입끼리의 `===` 비교는 더 이상 권장되지 않는다 (deprecated).

      그 비교 결과는 항상 true로 판단된다

    - 왜냐하면, Kotlin의 `Int`는 Java 코드에서 필요할때만 `Integer` 객체로 박싱되기 때문
      즉, 위의 코드를 Java 코드로 디컴파일해보면 `int` 형인 것을 확인할 수 있는데
      이처럼 객체가 아닌 경우에 참조 비교를 하고있으니 항상 true를 반환한다는 것


**1-2) `String`의 경우: 문자열 상수 풀(String Pool)**

- JVM은 문자열을 효율적으로 관리하기 위해 **String Pool (intern pool)** 을 사용
- 즉, “10” 같은 **리터럴 문자열은 상수 풀에 한 번만 저장**되고,

  같은 리터럴을 다시 쓰면 같은 참조를 재사용


### 2. 리스트에서 remove()가 가능한 이유

- `MutableList.remove(element)`는 내부적으로 `equals()` 비교
  즉, `===` (참조 비교)가 아니라 `==` (값 비교)이기 때문에
  다른 참조라도 문자열 내용이 같다면 제거됨

---
### 게임 설계 과제

- 예외상황이 발생할 수 있으므로, 최하단에서 인터페이스를 많이 구현하는 것이 좋다

- Bottom-up이 훨씬 쉽다
    - 인터페이스를 활용하면 설계 가능하다
    - 세부 객체의 속성을 인터페이스로 전부 뽑고, 공통된 속성들을 묶어주면 된다
    - 마커 인터페이스: 메서드 설계 없이 속성만 붙인 것 (역할 부여)
    - 최상단에 Unit 같은걸로 다 묶는게 제일 안좋다…
