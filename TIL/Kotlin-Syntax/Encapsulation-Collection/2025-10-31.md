# 캡슐화, 컬렉션
1. [캡슐화](#캡슐화)
   - [데이터 Read-Only 만들기](#데이터를-외부에-read-only로-노출하는-방법)
   - [setter에서 유효성 검사하기](#setter에서-값의-타당성을-검사)
2. [컬렉션](#컬렉션)

### 📌 코드 리뷰

- `init { }`
  - 인스턴스가 생성되는 시점에 실행됨

- 예외를 던진다는 것은, 함께 개발하는 개발자에게

- `const val` 상수 값을 테스트하는 것은 큰 의미가 없다  
  한번 초기화한 값을 수정할 일은 없을거니까

- 테스트 코드에도 상수 활용해서 매직 넘버 줄이기

- 테스트를 왜 할까?
  - 인공지능은 단기 기억 > 테스트를 통해 맥락을 알려줌

---
# 캡슐화

> 휴먼 에러를 줄이고 싶다

- 캡슐화를 왜 하는가?
  1. 현실세계와 동일하게 하고 싶어서
    - 현실세계에서는 정보를 얻기 위해서는 getter가 필요하고,
    - 내 마음대로 정보를 제공할 수 있으므로 setter를 내가 정할 수 있다
  2. 다른 개발자가 잘 접근할 수 있게

## 접근 지정자 access modifier

- private
- public

- 클래스 다이어그램
  - `+` public
  - `-` private
  - `~` protected

## getter와 setter

> 외부에서 쓰는 것은 막고 싶지만, 읽는 것은 마음대로 할 수 있게는 하고 싶다


- 메서드를 경유한 필드 조작
  - **getter**: 읽기 전용 프로퍼티를 구현할 때 사용
  - **setter**: 쓰기 전용 프로퍼티를 구현할 때 사용


- **프로퍼티 property**
  - 내부적으로 getter와 setter를 가지고 있음
  - Kotlin의 모든 변수는 프로퍼티임
  - `var` 은 private 변수로 선언되고, 게터 세터를 가지고
  - `val` 은 private 변수로 선언되고, 게터만 가져서 수정이 불가능함
  - var나 val이 없는 생성자 파라미터는 게터 세터가 없어서, 직접 접근이 불가능 > 값으로만 사용 가능

### 데이터를 외부에 Read-Only로 노출하는 방법

1. **getter 재정의**

```kotlin
class Hero(
    name: String,
    hp: Int,    // 생성한 파라미터로만 사용
    var sword: Sword? = null,
) {
    private var _hp = hp    // 내부적으로 사용할 변수 _로 선언
    val hp: Int
        get() = _hp
}
```

- 언더바 `_` 를 붙이는 것이 관행임
- 클래스 내부에서 자유롭게 사용할 `private var` 변수를 생성자 파라미터의 값으로 초기화한다
- 이후 해당 변수를 사용하고, 외부에서 `val` 변수에 접근할 때 _hp를 반환하여 읽기 전용으로 사용한다

1. **setter 재정의**

```kotlin
class Hero(
    name: String,
    hp: Int,    // 생성한 파라미터로만 사용
    var sword: Sword? = null,
) {
		var hp: Int = hp
				private set  // 클래스 밖에서 쓰기 불가
}
```

- setter를 private으로 설정하여 클래스 내부에서만 값을 변경할 수 있게 함


### setter에서 값의 타당성을 검사

> 유효성 검사할 때 주소 사용  
예외 처리로 더 편리하게 구현할 수 있어서 이후에는 잘 안 씀


```kotlin
class Hero(
    name: String,
    hp: Int,    // 캡슐화
    var sword: Sword? = null,
) {
    // setter에서 유효성 검사하는 방법
    var name: String = name
        set(value) {
            require(value.length > 1) { "이름이 너무 짧습니다" }
            require(value.length < 8) { "이름이 너무 깁니다" }
            field = value   // backing field
        }
}
```

- 생성자에 `val`, `var` 이 없으면 getter, setter가 없는 것으로 간주함. 즉 멤버가 아님
- backing field:
  - 프로퍼티의 값을 저장하기 위한 실제 필드 값
  - `field` 로 접근 가능
  

### +)

- `IllegalArgumentException("메세지")` 는 `require`과 같다
  - `require` 에서 내부적으로 해당 예외를 던진다

- Kotlin에서 들여쓰기(indentation)은 문법적인 기능이 없다
  - 따라서 getter, setter를 재정의할 때 tab을 하는 것은 코드 컨벤션일 뿐이다

```kotlin
val hp: Int
    get() = _hp
```

```
val hp: Int get() = _hp
```

---

# 컬렉션

### 자료구조

- 배열 (Array)
  - 같은 데이터 타입을 정해진 크기 만큼 저장할 수 있음
  - 연속적인 메모리 공간이 할당됨


- 연결 리스트 (List)
  - 다음 데이터의 주소값을 가지고 있어서 삽입, 삭제가 편리함
  - 순회는 느릴 수 있음

- 스택 (Stack)
- 큐 (Queue)

### List

- list
- mutableList<T>

### Set

- List의 contains보다 압도적으로 빠름
  - hash 알고리즘을 사용하기 때문에

### Map

> key-value 쌍으로 이루어진 자료구조


- Pair 객체
  - String에서 제공
  - `"name".to("홍길동")` == `"name" to "홍길동"`
    == `Pair("name", "홍길동")`

  - Pair 객체를 생성하는 함수인데, 그냥 문법인 것처럼 보이게 만들어 둔 것


- 요소 참조
  - 불변 리스트더라도, 인스턴스의 주소값을 가지고 있는거라 해당 필드가 수정 가능하다면 내부 요소는 수정될 수 있다