# Kotlin 기초 정리 – 객체지향, 캡슐화, 프로퍼티, 컬렉션 정리

---

## 💡 객체지향(Object-Oriented Programming)

### 캡슐화(Encapsulation)

- 클래스나 인스턴스를 통해 현실세계를 표현할 수 있지만,  
  실수로 속성을 잘못 수정하는 **휴먼 에러(human error)** 는 여전히 발생할 수 있다.
- 이를 방지하기 위해 **캡슐화**를 사용한다.  
  → 클래스 내부 상태를 감추고, 메서드를 통해서만 접근하도록 제한한다.

---

## 🔒 접근 지정자(Access Modifier)

| 제한 수준 | 키워드       | 접근 가능 범위      |
|-------|-----------|---------------|
| 엄격    | `private` | 자기 자신의 클래스 내부 |
| 느슨    | `public`  | 모든 클래스 (기본값)  |

---

## getter / setter 를 통한 필드 조작

- **getter** : 읽기 전용 필드를 만들 때 사용
- **setter** : 쓰기 전용 또는 값 검증이 필요한 필드를 만들 때 사용

---

## getter / setter 의 장점

- **Read Only / Write Only** 구현 가능
- 클래스 내부 설계를 자유롭게 변경 가능
- 값 변경 시 **유효성 검증 로직** 추가 가능
- 불변성(`val`)과 변경 가능성(`var`)을 명확히 구분

---

### Kotlin에서의 특징

- `val` → getter만 생성
- `var` → getter + setter 생성
- Kotlin에서는 명시적으로 안 보여도 내부적으로 자바의 getter/setter로 변환됨.

---

## 프로퍼티(Property)와 필드(Field)

| 구분                       | 설명                                        |
|--------------------------|-------------------------------------------|
| **필드(Field)**            | 실제 데이터 저장 공간                              |
| **프로퍼티(Property)**       | `getter`와 `setter`를 통해 필드에 접근             |
| **백킹 필드(Backing Field)** | 프로퍼티의 실제 값을 저장하는 숨겨진 필드 (`field` 키워드로 접근) |

💡 프로퍼티명 앞에 `_`(언더바)를 붙여 내부 전용으로 사용하는 관례가 있다.  
예: `_hp`, `_name`

---

## 생성자와 프로퍼티

- 생성자에 `var` 또는 `val`을 붙이지 않으면 → 단순 **파라미터** (멤버 아님)
- 붙이면 자동으로 **프로퍼티**가 됨
  ```kotlin
  class Person(name: String)  // 단순 파라미터
  class Person(val name: String) // 프로퍼티 (getter 자동 생성)

---

# 🗂️ 컬렉션(Collection)

| 컬렉션      | 설명                                 |
|----------|------------------------------------|
| **List** | 순서가 있는 자료 구조 (중복 허용)               |
| **Set**  | 순서가 없는 집합 (중복 불가, 탐색 빠름)           |
| **Map**  | `key` - `value` 쌍으로 저장 (key 중복 불가) |

---

## 배열 vs 리스트

| 구분    | 배열(Array)             | 리스트(List) |
|-------|-----------------------|-----------|
| 크기    | 고정                    | 가변        |
| 삽입/삭제 | 느림                    | 빠름        |
| 탐색    | 빠름                    | 느림(상대적)   |
| 특징    | 중간 삭제 시 뒤 요소가 앞으로 당겨짐 | 크기 자동 조정  |

---

## 자료구조

- **List / Set** : `iterator` 제공 → 요소 순회 가능
- **Stack (스택)** : 후입선출 (LIFO) — `undo/redo` 구현에 활용
- **Queue (큐)** : 선입선출 (FIFO) — 프린트 대기열, 작업 큐 등에서 사용

---

## ⚡ Kotlin에서의 컬렉션

- `Set` → **중복 불가, 빠른 탐색**
- `Map` → **Key는 유일, Value는 중복 가능**

| 컬렉션      | 불변형 생성     | 가변형 생성            | 중복              | 순서   | 비고            |
|----------|------------|-------------------|-----------------|------|---------------|
| **List** | `listOf()` | `mutableListOf()` | ✅ 가능            | ✅ 있음 | 순서 중요할 때      |
| **Set**  | `setOf()`  | `mutableSetOf()`  | ❌ 불가            | ❌ 없음 | 중복 제거 및 빠른 검색 |
| **Map**  | `mapOf()`  | `mutableMapOf()`  | key ❌ / value ✅ | ❌ 없음 | key-value 저장용 |

> 가능하면 기본형을 사용하여 휴먼 에러를 줄이는 것이 좋다.

---

## 📘 알아두면 좋은 내용

- **방어적인 코드를 지향하자**
- **상수값 테스트는 큰 의미가 없다.**

---

## 과제 리뷰

> ### 다음을 수행하는 코드를 작성하시오.
> 
> 다음 2개의 클래스 “Wizard (마법사)”, “Wand (지팡이)” 를 작성하시오. 마법사는 지팡이를 들 수 있습니다.
>
> 작성한 Wand 클래스와 Wizard 클래스에 대해, 아래의 규칙에 따라 타당성 검사를 추가하시오.  
> 부정한 값이 설정 될 경우에는 “IllegalArgumentException(“메세지")” 를 작성하여 프로그램을 중단 시킵니다.
> 1) 마법사나 지팡이의 이름은 null 일 수 없고, 반드시 3문자 이상이어야 한다
> 2) 지팡이의 마력은 0.5 이상 100.0 이하여야 한다.
> 3) 마법사의 MP는 0 이상이어야 한다.
> 4) HP가 음수가 되는 상황에서는 대신 0을 설정 되도록 한다.

```kotlin
class Wizard(
    name: String,           // 이름
    hp: Int,                // 체력
    mp: Int = DEFAULT_MP,   // 마나
    wand: Wand?,            // 완드
)
```

- `wand`는 `Wand?`로 선언되어 null 가능
- `mp`는 기본값을 `companion object`안에 설정

```kotlin
var name: String = name
set(value) {
    if (value.length < 3) {
        throw IllegalArgumentException("이름이 3자 이상이어야 합니다.")
    }

    if (value.length > 8) {
        throw IllegalArgumentException("이름이 8자 이하이어야 합니다.")
    }

    if (value.contains(" ")) {
        throw IllegalArgumentException("이름에 공백이 포함되어 있습니다.")
    }

    if (value.contains(Regex("[^A-Za-z0-9가-힣]"))) {
        throw IllegalArgumentException("이름에 특수문자가 포함되어 있습니다.")
    }

    field = value
}
```

- 마법사의 이름을 저장하는 **프로퍼티**
- `setter`를 활용한 **타당성 검사**
- `field`는 `backing field(실제 저장소)`
- 범위, 공백 검사, 특수문자 검사 추가

```kotlin
var mp: Int = mp
set(value) {
    if (value < 0) {
        throw IllegalArgumentException("MP는 0 이상이어야 합니다.")
    }

    if (value > 1000) {
        throw IllegalArgumentException("MP는 1000 이하이어야 합니다.")
    }

    field = value
}
```

- 범위 추가

```kotlin
var hp: Int = hp
set(value) {
    field = if (value < 0) 0 else value
}
```

- 비교적 간단한 구조라서 한줄 조건식으로 설정

---

> ### Person 클래스를 작성하시오.
>
> 1) 이름과 태어난 해를 생성자로 받는다 (name, birthYear)
> 2) 이름과 태어난 해는 한번 정해지면 수정이 불가능하다.
> 3) age 프로퍼티를 통해 나이를 제공하지만, 임의로 수정은 불가능하다.
> 4) 나이 계산은 올해년도에서 birthYear 년도를 뺀 값을 리턴한다  
     >    a. 현재 시간과 날짜를 구하는 방법은 검색 해 볼 것

```kotlin
class Person(
    val name: String,   // 이름
    val birthYear: Int, // 태어난 해
)
```

- 기본값 X, `val`로 변경 불가

```kotlin
private val currentYear: Int = LocalDate.now().year
```

- 외부에서 접근 불가
- `LocalDate.now().year`은 올해 연도를 정수로 가져옴

```kotlin
val age: Int
get() = LocalDate.now().year - birthYear
```

- `getter`로 직접 정의
- 연산 결과를 즉시 반환, `setter`가 없어서 수정 불가

---

> ### 1번 다음을 수행하는 코드를 작성하시오.
> 
> 다음 정보를 저장하기 좋은 컬렉션을 List, Set, Map 중 고르시오. 그 이유는?
>
> 1) **대한민국의 도시 이름 모음 (순서 상관 없음)**  
     >    도시는 순서가 상관없기 때문에 순서 상관 없고 속도가 빠른 Set이 좋다.
>
> 2) **10명 학생의 시험 점수**
     >    학생의 시험 점수는 순서가 중요하지 않을 수 있지만, 학생 이름 혹은 학번과 점수로 묶어서 저장하기 좋기에 Map이 좋다.
>
> 3) **대한민국의 도시별 인구수 (순서 상관 없음)**  
     >    도시별 인구수는 순서가 중요하지 않고, 묶어서 저장하기 좋아서 Map이 좋다.

---

> ### 다음을 수행하는 코드를 작성하시오.
>
> 1) 이름을 가지는 Person 클래스를 작성하시오. Person은 반드시 이름을 포함해야 합니다.
> 2) 이름이 ‘홍길동’, ‘한석봉’인 Person 인스턴스를 생성하고, List에 담습니다.
> 3) List에 담긴 모든 Person 인스턴스의 이름을 표시하시오.

```kotlin
class Person(val name: String, var age: Int? = null)
```

- 이름은 필수, 나이는 3번 문제에 사용하기위해 null을 허용한다

```kotlin
val person1 = Person("홍길동")
val person2 = Person("한석봉")

val people: List<Person> = listOf(person1, person2)

for (person in people) {
    println(person.name)
}
```

---

> ### 다음을 수행하는 코드를 작성하시오.
>
> 연습문제 2에서 작성한 Person 클래스로 생성한 ‘홍길동’, ‘한석봉’의 나이를 각각 20, 25살이라고 할 때, 이름과 나이를 쌍으로 적당한 컬렉션에 넣습니다.  
> 그 다음, 컬렉션에 저장한 값을 하나씩 다음과 같이 출력합니다.
>
> “홍길동의 나이는 20살”  
> “한석봉의 나이는 25살”

```kotlin
val person1 = Person("홍길동", 20)
val person2 = Person("한석봉", 25)

val people: Map<String, Int?> = mapOf(
    person1.name to person1.age,
    person2.name to person2.age
)

people.entries.forEach {
    println("${it.key}의 나이는 ${it.value}살")
}
```

- 이름을 `key`, 나이를 `value`로 설정
- `entries`는 `Set<Map.Entry<K,V>>`
- `it`은 **람다식(익명 함수)** 기본 제공되는 매개변수이다.