## Test Code 기초

### 1. 테스트 코드를 통한 품질 향상

| **테스트 종류**                    | **설명**                                      | **예시**                      |
|-------------------------------|---------------------------------------------|-----------------------------|
| **수동 테스트 (Manual Test)**      | 사람이 직접 실행하고 결과를 확인하는 테스트 방식                 | `print()`로 출력 확인, 콘솔에서 값 비교 |
| **단위 테스트 (Unit Test)**        | 개별 함수나 메서드 등 **하나의 단위**를 독립적으로 검증하는 테스트     | `@Test`를 사용한 함수 테스트         |
| **통합 테스트 (Integration Test)** | 여러 개의 함수나 클래스가 **함께 동작할 때의 상호작용**을 검증하는 테스트 | UI 테스트, API 연동 테스트 등        |

---

### 2. 테스트 방법론

#### 화이트 박스 테스트

- 내부 구조와 동작에 중점을 두고 테스트하는 방법
- 코드의 내부 로직, 제어 흐름, 데이터 흐름 등을 이해하고 검증하는 데에 사용
- 테스트 케이스를 설계할 때 코드의 특정 부분을 직접 확인
- 주요 기법으로는 구문 검사, 경로 검사, 조건/분기 검사 등

#### 블랙 박스 테스트

- 소프트웨어의 내부 구조를 무시하고 기능을 테스트하는 방법
- 시스템이 어떻게 동작하는지에 대한 내부 정보를 알 필요 없이 사용자 관점에서 테스트
- 테스트 케이스는 입력 값과 예상 출력 값에 기반하여 설계
- 요구 사항을 충족하는지 확인하고, 시스템의 기능적 및 비기능적 요구 사항을 테스트
- 주요 기법으로는 등가 분할, 경계 값 분석, 상태 전이 테스트 등

#### Unit Test (단위 테스트)

> 특정 모듈이 **의도한 대로 잘 작동하는가**를 테스트하는 가장 작은 단위의 테스트 </br>

- 모듈 = 메서드, 기능

#### 테스트의 장점

- 장애에 관한 신속한 피드백
- 개발 주기에서 조기 장애 감지
- 회귀에 신경 쓸 필요 없이 코드를 최적화할 수 있도록 하는 더 안전한 코드 리팩터링
- 기술적 문제를 최소화하는 안정적인 개발 속도...? -> 더 느려질 지도..? 다만 시간이 지날수록 good!

#### 테스트 케이스

> 가능한 모든 가능성의 범위를 테스트하는 것 </br>
> ex) 동등 분할, 경계값 분석

#### 단위 테스트가 꼭 필요한 경우

- DB (특히 더 중요)
    - 스키마가 변경되는 경우
    - 모델 클래스가 변경되는 경우

- Network
    - 예측한 데이터가 제대로 들어오는지

- 데이터 검증
    - 예측한 데이터를 제대로 처리하고 있는지

#### 테스트 성공

- 테스트가 성공하도록 코드를 수정
- 테스트 중심으로 개발하는 방법론 TDD (Test Driven Development)

#### 예외 발생 테스트

- Exception 검증

```kotlin
assertThrows<Exception> { a.transfer(b, 600) }
```

- 반대는 assertDoesNotThrow (정상 동작 검증)

```kotlin
assertDoesNotThrow { a.transfer(b, 400) }
```

---

### + 단위 테스트 작성 시 유의점

> 하나의 테스트 함수에서는 하나의 목적만 검증 </br>
> → 원인 추적이 쉽고, 실패 시 어디서 문제인지 명확히 알 수 있다.

#### 과제로 작성했던 Cleric 생성 테스트

```kotlin
@Test
fun `Cleric 생성 조건 케이스`() {
    val case1 = Cleric("아서스")
    assertEquals(50, case1.hp)
    assertEquals(10, case1.mp)

    val case2 = Cleric("아서스", hp = 35)
    assertEquals(35, case2.hp)
    assertEquals(10, case2.mp)

    val case3 = Cleric("아서스", hp = 40, mp = 5)
    assertEquals(40, case3.hp)
    assertEquals(5, case3.mp)
}
```

- 한 함수 안에서 3가지 경우를 모두 테스트
- 코드 길이가 길어지고 하나라도 실패하면 전체 테스트가 실패로 표시
- 디버깅 시 **“어떤 케이스에서 실패했는지”** 직접 출력이나 로그로 확인 필요

---

### + 반면 테스트를 할 수 없는 코드도 존재!

```kotlin
@Test
fun `이름 없이 Cleric 생성 불가`() {
    // Cleric()
    // 컴파일 타임에 막히므로 실행 테스트는 불가
    // 이름 없는 생성자 호출 시 IDE 컴파일 에러 확인
    assertTrue(true)
}
```

> 컴파일 타임 에러는 테스트 코드로 검증할 수 없다 </br>
> → 테스트는 **프로그램이 컴파일된 후 실행되는 로직(런타임 동작)** 을 검증하기 때문