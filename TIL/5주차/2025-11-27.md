# 객체지향 설계 · 패턴

## 1️⃣ 응집도(Cohesion)와 결합도(Coupling)

### 응집도 (Cohesion)
- 모듈이 **하나의 목적을 수행하는 요소들간의 연관성 척도**
- **모듈 내부의 기능적인 응집 정도**를 나타냄

- 높은 응집도
    - 모듈이 **하나의 특정 작업이나 기능에 집중**
    - 예) `UserAuthentication` 클래스
        - 로그인, 로그아웃, 비밀번호 변경 기능

- 낮은 응집도
    - 모듈이 여러 가지 **서로 관련 없는 작업을 수행**
    - 예) `Util` 클래스
        - 문자열 처리, 파일 읽기, 날짜 계산 기능

---

### 결합도 (Coupling)
- 모듈이 **다른 모듈에 의존하는 정도의 척도**
- **모듈과 모듈간의 상호 결합 정도**를 나타냄

- 낮은 결합도
    - 모듈이 서로 **독립적으로 작동할 수 있을 때**
    - 예) `UserAuthentication` 클래스가
        - 특정 클래스가 아니라 **인터페이스를 통해** 사용자 정보를 가져오는 경우

- 높은 결합도
    - 모듈이 서로 **강하게 연결**되어 있을 때
    - 예) `UserAuthentication` 클래스가
        - 특정 클래스의 **내부 구현에 직접 의존**하는 경우

---

## 2️⃣ SOLID 원칙 한줄 메모

- **SRP (단일 책임 원칙)**
    - 한 클래스는 **하나의 책임**만 가져야 한다
    - 외부 객체는 **생성자로 주입 받아라**
    - 메서드가 하나 있어야 한다는 의미가 아니라,
        - “변경 이유가 한 가지여야 한다”는 의미

- **OCP (개방-폐쇄 원칙)**
    - 코드는 **확장에는 열려 있고, 변경에는 닫혀 있어야** 한다

- **LSP (리스코프 치환 원칙)**
    - 하위 타입은 상위 타입을 **대체할 수 있어야 한다**
    - `LSP is a 원칙을 지켜라` → 상속/다형성 설계 시 항상 염두에 둘 것

- **ISP (인터페이스 분리 원칙)**
    - 인터페이스 하나에 **다 때려 넣지 말고 여러 개로 쪼개라**
    - 클라이언트가 **필요한 기능만** 의존하도록 설계

- **DIP (의존관계 역전 원칙)**
    - 고수준 모듈과 저수준 모듈이 **추상화에 의존**해야 한다
    - “DIP 다형성” → 인터페이스에 의존해서 구현을 갈아끼울 수 있게 만들기

---

## 3️⃣ 디자인 패턴 요약

> 결론 : **설계 원칙과 노하우를 정리한 것. 선배님들이 정리한 것을 공부하자.**  
> 소프트웨어 디자인에서 특정 문맥에서 공통적으로 발생하는 문제에 대해 **재사용 가능한 해결책**

### 생성 관련

- **빌더 패턴 (Builder)**
    - 복잡한 객체를 **단계적으로 생성**하는 데 유용
    - 예) `StringBuilder`

- **팩토리 패턴 (Factory)**
    - **인스턴스를 만드는 패턴**
    - 생성 로직을 한 곳에 모아두고, 클라이언트는 타입만 선택

- **싱글톤 패턴 (Singleton)**
    - **1개의 인스턴스만 생성되는 것을 보증**하기 위한 패턴
    - 인스턴스 생성을 여러 번 시도해도 **1개의 인스턴스가 공유됨**
    - 캐시나 공유 데이터, 처리의 효율화 등에 사용되는 테크닉

---

### 구조/행위 관련

- **Decorator 패턴**
    - 기존 객체에 기능을 **데코레이션 형태로 덧붙이는** 패턴

- **Iterator 패턴**
    - 내부 구조를 숨기고 **순차적으로 컬렉션을 순회**할 수 있게 하는 패턴

- **Facade 패턴**
    - 내부를 감추고 **심플한 인터페이스만 제공**
    - 복잡한 서브시스템을 한 번에 감싸는 창구

- **Strategy 패턴 (전략 패턴)**
    - 런타임에 **알고리즘을 동적으로 교체**할 수 있도록 설계
    - 알고리즘을 인터페이스로 분리하고, 구현체를 갈아끼우는 방식

- **Observer 패턴 (옵저버 패턴)**
    - 객체의 상태 변화를 관찰하는 관찰자들(옵저버)을 등록해 두고,
    - 상태 변화가 있을 때마다 **객체가 직접 옵저버에게 통지**
    - 분산 이벤트 핸들링, 발행/구독 모델, 콜백 함수 등에 사용

---

## 4️⃣ 아키텍처 디자인

### MVC
- **M(Model)** : 도메인, 데이터, Repository
- **V(View)** : 화면
- **C(Controller)** : 입력 처리, 흐름 제어
- 한 줄 메모:
    - `view - 화면, model - repository`

### MVP
- View는 **화면 표시**,
- Presenter가 View와 Model 사이에서 대부분의 로직을 담당

### MVVM
- ViewModel이 **상태와 로직을 가지고 View와 데이터 바인딩**
- 선언형 UI, 바인딩 프레임워크에서 많이 사용

### 클린 아키텍처
- 의존성 방향: **바깥 → 안쪽**
- 도메인/유즈케이스 중심, UI·DB·프레임워크는 바깥 레이어
- DIP(의존관계 역전 원칙)를 강하게 사용하는 구조

---

## 5️⃣ 기타 메모

- **Result 패턴**
    - dataSource를 가져올 때 result 패턴을 써도 되지만
    - 계층이 많아지면 **너무 복잡해질 수 있다**는 점을 주의

- **typealias**
    - 내가 원하는 타입 이름으로 **별칭을 선언**해서 가독성을 높인다

- **SRP 관련 메모**
    - `srp 단일 책임 원칙 - 메서드가 하나 있어야한다는 의미가 아니다`
    - “변경 이유가 하나”가 포인트

- **DIP / 의존성 메모**
    - `adp 서로 의존성` → DIP로 정리
    - 고수준이 저수준에 직접 의존하지 않도록 설계
