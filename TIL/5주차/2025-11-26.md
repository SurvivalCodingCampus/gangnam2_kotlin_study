# Result 패턴 정리

## 1️⃣ 개념

- **Result 패턴**
    - 성공과 실패를 **예외(throw)** 대신 **값**으로 표현하는 패턴.
    - 성공 시에는 `데이터`, 실패 시에는 `에러 정보`를 담는 객체를 사용한다.
    - 즉, “에러가 나면 터지는 것”이 아니라  
      **항상 `Success` 또는 `Error` 중 하나의 객체로 반환**된다.

- **sealed class와의 조합**
    - `sealed class Result<out D, out E>` 형태로 정의해서
        - `Success<D>` : 성공 시 데이터를 담는 타입
        - `Error<E>`   : 실패 시 에러를 담는 타입
    - sealed class는 **타입 봉인 효과**가 있어서  
      enum처럼 “가질 수 있는 서브 타입이 정해져 있다”는 것을 컴파일러가 알고 있다.
    - 따라서 `when(result)`를 사용할 때  
      **모든 서브타입을 처리하지 않으면 컴파일러가 경고/에러로 알려줄 수 있다.**

```kotlin
sealed class Result<out D, out E> {
    data class Success<out D>(val data: D) : Result<D, Nothing>()
    data class Error<out E>(val error: E) : Result<Nothing, E>()
}
```
```kotlin
fun handleUserResult(result: Result<User, NetworkError>) {
    when (result) {
        is Result.Success -> {
            val user: User = result.data
            // 성공 처리
        }
        is Result.Error -> {
            val error: NetworkError = result.error
            // 에러 처리
        }
    }
}
```

- **Unit vs Nothing**
    - `Unit`
        - “돌려줄 유의미한 값이 없다”라는 의미의 **정상 종료**.
        - 예: `Result<Unit, E>` → 성공했지만 반환할 데이터가 없을 때.
    - `Nothing`
        - “절대 값이 존재하지 않는다”는 의미의 **비정상 종료/불가능한 상태** 표현용 타입.
        - 예: `Result<Nothing, E>` → 성공 데이터는 절대 존재할 수 없고, 에러만 의미가 있을 때.

- **타입 파라미터**
    - `D` : Data (성공 시 데이터 타입)
    - `E` : Error (실패 시 에러 타입)
    - `out` 키워드
        - 공변(covariant) 표시.
        - “읽기 전용”으로 사용하겠다는 의미.
        - `Result<Child, E>` 를 `Result<Parent, E>` 로 다룰 수 있게 해 줘서 활용 범위가 넓어진다.

---

## 2️⃣ 에러 처리의 기본 아이디어

- 기존 `try-catch`
    - 런타임 예외를 잡는 구조일 뿐,
    - **도메인/논리적 에러를 타입으로 표현하지 못한다.**
    - `catch`를 빼먹어도 컴파일러가 강제하지 못하고,
    - 예외가 어디서 터질지 코드만 보고 추론하기 어렵다.

- Result 패턴
    - **“성공/실패를 값으로 반환”** 함으로써
        - 예외를 던지지 않고
        - 항상 `Result.Success` 또는 `Result.Error` 중 하나를 반환한다.
    - 호출자는 반환값을 보고 **반드시 성공/실패를 모두 처리**해야 한다.
    - 논리적인 에러(예: 유효하지 않은 id, 비어있는 리스트 등)도  
      명시적인 에러 타입 `E`로 표현할 수 있다.

---

## 3️⃣ 장점 정리

1. **타입 안전성 향상**
    - 성공 타입 `D`, 에러 타입 `E`가 명시되어 있어  
      어떤 상황에서 어떤 타입이 오는지 컴파일 단계에서 알 수 있다.

2. **에러 처리 강제성**
    - `Result<D, E>`를 받으면,
        - `when(result)` 또는 `if (result is Result.Success)` 등으로  
          **성공/실패를 반드시 분기 처리**하게 된다.
    - `when`에서 모든 서브타입을 처리하도록 강제할 수 있어  
      빠뜨린 에러 케이스를 줄일 수 있다.

3. **에러 타입의 명확한 문서화**
    - `Result<User, NetworkError>`처럼,
        - “이 함수는 무엇을 반환하고, 어떤 에러가 날 수 있는지”를  
          함수 시그니처만 봐도 알 수 있다.
    - 개발자 간의 의사소통, 코드 읽기, 유지보수에 유리하다.

4. **try-catch 남용 방지**
    - 도메인 에러를 전부 `throw` 하는 대신  
      `Result.Error`에 담아서 반환하기 때문에
    - 진짜 예외(`NullPointerException`, `IllegalStateException` 등)는  
      **진짜 예외 상황**에만 사용하게 된다.

5. **비즈니스 로직과 에러 처리 분리**
    - 비즈니스 로직 함수는 `Result`만 반환하고,
    - 호출하는 쪽(ViewModel, UseCase 등)에서  
      `when(result)`로 UI 반응, 로깅 등을 분리해서 처리할 수 있다.

6. **Nullable 타입 사용 감소**
    - `User?` 대신 `Result<User, Error>`를 사용하면
        - “값이 없음(null)”인지
        - “에러가 발생했음”인지
        - 둘 사이가 명확히 구분된다.

7. **테스트 용이성**
    - 테스트에서
        - 성공 케이스: `Result.Success(testUser)`
        - 실패 케이스: `Result.Error(NetworkError.Timeout)`
    - 처럼 **값으로 직접 주입**할 수 있어  
      에러 시나리오 테스트가 쉬워진다.

8. **패턴 매칭을 통한 가독성 향상**
    - `when(result)` 패턴으로
        - 성공/실패를 한 눈에 보기 좋은 구조로 작성할 수 있고,
        - 각 케이스별 UI/로직을 분리하기 쉽다.

---

## 4️⃣ 핵심 요약 문장

- **Result 패턴**은 성공과 실패를 명확하게 분리하고,  
  예외 대신 **값(객체)** 으로 에러를 다루는 방식이다.
- **sealed class Result**는
    - 가능한 서브타입을 `Success` / `Error`로 봉인해서
    - `when` 패턴 매칭으로 모든 경우를 처리하기 쉽게 만들어 준다.
- 예외 `throw` 없이도
    - 성공/실패를 타입으로 구분하고,
    - 에러 정보(`E`)를 함께 전달할 수 있다.
- `when`을 활용하면
    - **성공 / 실패에 대한 처리 로직을 반드시 작성하도록 강제**할 수 있다.
- 앱의 규모나 복잡도에 따라
    - 단순한 `Result<D, E>` 구조를 쓰거나,
    - 필요하다면 더 많은 서브타입을 가지는 “버전 2” 스타일(예: Loading, Empty 등)을 도입할 수 있다.
- 정리하면,
  > Result 패턴은 **“안 터지고(success/failure 객체로만 흐르는)” 에러 처리 방식**이고,  
  > sealed class는 enum의 상위 호환처럼  
  > **서브타입이 고정된 계층을 만들고 패턴 매칭을 강제**하는 도구이다.
  