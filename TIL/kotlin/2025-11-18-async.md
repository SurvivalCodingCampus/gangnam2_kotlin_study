# 비동기 프로그래밍

### 용어 정리

- 동기
- 비동기
- 동시성
- 병렬성

### 동기 vs 비동기

- 작업 완료를 기다리는 방식의 차이
- 동기: 한 작업이 끝날때까지 기다렸다가 다음 작업을 시작함
- 비동기: 기다리지 않고 다른 작업을 시작함

### 동기(Synchronous) 프로그래밍

### 비동기(Asynchronous) 프로그래밍

### 동시성 vs 병렬성

- 여러 작업을 처리하는 방식에 대한 차이
- 동시성: 여러 작업을 번갈아가면 처리하는 것. 논리적이고 시간 분할을 통해 작업을 처리.
- 병렬성: 여러 작업을 실제로 동시에 처리하는 것. 작업을 물리적으로 동시에 실행하는 방식.

### 동시성과 병렬성 활용 사례

- 동시성은 여러 작업을 번갈아 처리하는 방식으로, 웹 서버의 비동기 I/O 처리나 네트워크 요청 대기 중 다른 작업을 수행하는 케이스에서 활용됩니다. 예를 들어, 대규모 트래픽을 처리하는 웹 서버는 요청이 대기
  상태일 때 다른 요청을 처리할 수 있어 응답 속도를 개선합니다.
- 병렬성은 멀티코어 서버 환경에서 여러 CPU 코어가 실제로 동시에 여러 작업을 처리하는 방식입니다. 머신러닝 프레임워크인 TensorFlow나 PyTorch는 GPU 코어를 활용해 병렬 연산으로 모델 학습 시간을
  줄이는 대표적인 사례입니다.

### 동시성(Concurrency)

### 병렬성(Parallelism)

### 프로세스(Process), 스레드(Thread)

프로세스는 운영체제로부터 자원을 할당받아 실행 중인 프로그램의 독립적 인스턴스입니다. 각각의 프로세스는 코드, 데이터, 힙, 스택 등의 메모리 영역을 독립적으로 가지고 있으며, 다른 프로세스와 메모리를 공유하지
않습니다.   
프로세스 간의 통신은 복잡하고 느린 IPC(Inter-Process Communication)를 통해 이루어집니다.    
스레드는 한 프로세스 내에서 실행되는 작업 흐름 단위로, 같은 프로세스 내의 다른 스레드들과 코드, 데이터, 힙 영역을 공유하지만 각자 독립적인 스택을 가집니다. 스레드끼리는 메모리를 공유하기 때문에 데이터 교환이
쉽고, 생성과 전환 속도가 프로세스보다 빠르며 오버헤드가 적습니다. 여러 스레드를 통해 하나의 프로그램 내에서 병렬 처리와 동시성을 구현할 수 있습니다.  
요약하자면, 프로세스는 독립된 실행 단위이며 스레드는 프로세스 내의 경량 실행 단위로서 자원을 공유하며 동작한다는 점이 가장 큰 차이입니다.

### Coroutine

- Kotlin 표준 병행 프로그래밍 API
- 코루틴은 오래 걸리는 작업을 수행하는 방법 중 우아하고 효율적인 방법 중 하나이다
- 콜백 기반 코드를 순차 코드로 변환할 수 있다
- 순차 코드는 읽기 쉽고 에러 처리가 편하다

### Coroutine 사용시 이점

- 경량
    - 코루틴은 실행 중인 스레드를 차단하지 않는 정지(suspend)를 지원하여 메모리를 절약하면서 많은 동시 작업을 처리한다.
- 메모리 누수 감소
    - 스레드를 활용한 동기화에서는 휴먼 에러에 따른 메모리 누수나 데드락과 같은 위험이 크지만, 코루틴은 상대적으로 안전하며, 생명주기 및 리소스 관리가 쉬운 편이다.
- 스레드보다 가볍고 효율적이다.
- 많은 안드로이드 API가 코루틴을 공식 지원하고 있다.

### 1. 코루틴을 만드는 방법: 코루틴 빌더(Coroutine Builder)

- 새로운 코루틴을 시작하는 함수를 코루틴 빌드라고 한다.
    - runBlocking, ContextScope.launch, ContextScope.async
- 코루틴 빌더는 코루틴의 생명주기를 제한하는 CoroutineScope를 생성한다.
- launch 로 새로운 코루틴을 시작해도 독립적으로 동작.

- 대표적인 코루틴 빌더 함수:
    - `launch { ... }`: 결과를 반환하지 않는 코루틴을 시작, `Job` 객체를 반환
    - `async { ... }`: 값을 비동기적으로 계산해서 `Deferred` 객체(미래 값)를 반환
    - `runBlocking { ... }`: 현재 스레드를 차단(block)해서 코루틴을 즉시 실행(테스트 또는 main 함수에서 주로 사용)

### 2. 코루틴 빌더의 동작 원리

- 코루틴 빌더를 호출하면, 지정한 **코루틴 스코프(scope)** 및 **컨텍스트(context)**에 따라 "새로운 코루틴 실행 블록"이 만들어집니다.
- 이 코루틴은 자체적으로 독립된 생명주기와 실행 흐름을 갖고, 내부에서 `suspend fun`(정지 함수)을 사용할 수 있습니다.
- 만약 부모 스코프(launch 등) 내부에서 또 다른 코루틴 빌더를 사용하면 자식-부모 코루틴 구조가 형성됩니다.

### 3. 빌더에 의한 구조적 동시성(Structured Concurrency)

- 부모-자식 코루틴 관계가 자동 관리되고, 예외나 취소도 전파됩니다.
- 코루틴의 생성과 종료, 에러 및 자원 관리가 체계적으로 됩니다.

### 4. 예시 코드

```kotlin
CoroutineScope(Dispatchers.Main).launch {
    async { /* 자식 코루틴 1, 비동기 결과 */ }
    launch { /* 자식 코루틴 2, 결과 없음 */ }
}
```

- 바깥쪽 launch가 부모, 그 안의 launch/async가 자식 역할

### withContext란?

- **기존 코루틴 내에서 "컨텍스트(Dispatcher 등)를 바꿔서 다른 작업을 수행"**할 때 사용하는 함수입니다.
- 새로운 코루틴을 만드는 게 아니라, 이미 실행 중인 코루틴의 "일시적인 문맥 변경/전환"만 담당합니다.
- 예시:
  ```kotlin
  withContext(Dispatchers.IO) {
      // IO 작업 수행
  }
  ```
- 이 코드는 기존 코루틴에서 블록 내의 작업만 IO Dispatcher에서 실행하지만, 코루틴 자체는 새로 생성되지 않습니다.

***

**정리:**

- `launch`, `async`, `runBlocking` 등은 코루틴 빌더(새 코루틴 생성)
- `withContext`는 코루틴 빌더가 아니라 "컨텍스트 전환용 함수"

### suspend

- suspend는 비동기 함수를 표기하는 코틀린 문법이다.
- suspend 함수가 실행되면 완료될 때까지 일시 중지 됨.
- 그 사이 다른 함수나 코루틴이 실행될 수 있음.

### `suspend` 함수란?

- `suspend fun`으로 선언하는 함수는 **코루틴 내에서만 호출할 수 있고, 중간에 일시적으로 실행을 멈출(suspend) 수 있는 함수**입니다.
- 이 함수는 **코루틴 빌더(launch, async 등) 또는 다른 suspend 함수**에서만 호출할 수 있습니다.
- 일반 함수에서는 직접 불러 쓸 수 없습니다.

### 역할과 특징

- 네트워크, IO, 딜레이처럼 오래 기다려야 하는 작업 도중에 **스레드를 차단하지 않고 작업을 일시 정지했다가, 적절한 시점에 자동 복귀**할 수 있습니다.
- 내부적으로 중단점(suspend point)을 가지고 있어, 코루틴 디스패처가 더 효율적으로 자원을 배분할 수 있습니다.
- `suspend` 함수는 동기 코드처럼 기술할 수 있어서, 복잡한 콜백 대신 깔끔하게 흐름을 표현할 수 있습니다.

### 코드 예시

```kotlin
suspend fun fetchUserData(): User {
    // 네트워크에서 데이터 가져오기
}

CoroutineScope(Dispatchers.IO).launch {
    val user = fetchUserData() // 코루틴에서 suspend 함수 호출
}
```

> 여기서 `fetchUserData()`는 네트워크 요청이 끝날 때까지 코루틴을 정지(suspend)시켰다가, 완료되면 다시 실행이 이어집니다.

***

**요약**

- `suspend`는 코루틴에서 "언제든 정지/재개 가능한 함수"임을 선언하는 키워드
- 스레드를 차단하지 않고 작업을 효율적으로 멈췄다 다시 시작할 수 있게끔 만듭니다
- 복잡한 비동기 로직을 순차적 코드처럼, 쉽고 안전하게 작성할 수 있도록 지원합니다.

### 코루틴은 기본적으로 순차 실행

### Job

- CoroutineBuilder 에 의해 작성된 코루틴
- launch 는 Job을 리턴한다.
- Job 을 통해 실행중인 코루틴을 제어할 수 있다.

### Job이란?

- 코루틴(launch, async 등)이 실행될 때, 그 "작업 단위(job)"를 추적·제어할 수 있는 객체입니다.
- **코루틴의 상태, 취소, 완료 등 관리용 API**를 제공합니다.

### 주요 역할/기능

- **취소:** 코루틴 실행 중 `job.cancel()`을 호출하면 해당 코루틴을 중단시킬 수 있습니다.
- **상태 확인:**
    - `job.isActive`: 실행 중인지 확인
    - `job.isCompleted`: 완료 여부 확인
    - `job.isCancelled`: 취소됐는지 확인
- **완료 대기:**
    - `job.join()`: 코루틴이 끝날 때까지 기다리기(blocking)
- **구조적 동시성:**
    - 부모-자식 관계, 여러 코루틴의 취소/완료가 연동됨

### 코드 예시

```kotlin
val job = CoroutineScope(Dispatchers.Default).launch {
    // 코루틴 본문
}
job.cancel()       // 코루틴 강제 취소
job.join()         // 코루틴 작업 끝날 때까지 대기
println(job.isActive)
```

- 위 예시에서 job을 통해 코루틴 제어/상태 확인 가능

### Dispatcher

- 코루틴이 어떤 스케줄러에 의해 수행될지를 지정할 수 있다.
- Default
    - 백그라운드 스레드
    - 코어 수에 비례해서 스레드를 만든다. 연산용
    - CPU에 부하를 줄 만한 처리 (로컬에서 List 정렬 등)
- Main
    - 메인 스레드에 연결되는 디스패처
- IO
    - 백그라운드 스레드
    - Input/Output 조작용
    - 상대적으로 많은 스레드를 만드는 디스패처 (DB 통신 / Http 통신)
- Unconfied
    - 특정 스레드를 한정하지 않음. 공식 문서에서는 보통 사용하지 않는다고 명시되어 있음

### withContext()

- 디스패처를 전환해 주는 함수

```kotlin
suspend fun saveFile(content: String) {
    withContext(Dispatchers.IO) {
        // 파일 저장 로직
        File("output.txt").writeText(content)
    }
}

// 사용 예시
fun main() = runBlocking {
    val content = "Hello, World!"
    saveFile(content)    // IO 디스패처에서 비동기로 실행
    println("File saved!")
}

```

### 디스패처 전환 사용 예

디스패처를 전환하여 Worker 스페드와 Main 스레드를 넘나들 수 있다.

```kotlin
fun main() = runBlocking {
    launch(Dispatchers.IO) {
        delay(3000)
        println("코루틴 1: ${Thread.currentThread().name}")
        withContext(Dispatchers.Main) {
            println("코루틴 2: ${Thread.currentThread().name}")
        }
    }
}

```

### CoroutineExceptionHandler

- 코루틴에서 예외가 발생했을 때 **핸들러로 처리**할 수 있게 해주는 코루틴 컨텍스트 요소.
- launch 등에서 예외가 발생하면 이 핸들러에 의해 처리됨.
- 예시:
  ```kotlin
  val handler = CoroutineExceptionHandler { _, exception ->
      println("코루틴 예외: $exception")
  }
  CoroutineScope(Dispatchers.Main + handler).launch { ... }
  ```

***

### Channel

- 코루틴 간 데이터를 **비동기적으로 주고받는 통로(파이프, 큐)**
- `close()`는 채널을 "닫아서" 더 이상 값을 보내거나 받을 수 없게 함(주로 데이터 전송 끝난 후 호출)
- **Hot stream**: 소비자가 없어도 데이터를 보낼 수 있음

***

### Flow

- 데이터 스트림을 콜드 방식으로 처리하는 비동기 시퀀스
- **emit()**: flow 내부에서 데이터를 발행(보냄)
- **flowOn()**: flow 동작을 특정 디스패처에서 실행(백그라운드, IO 등)
- **collect()**: flow에서 데이터를 소비(수신)하는 구간, subscribe와 비슷
- **Cold stream**: collect()를 할 때마다 새 스트림 시작, 소비자가 없으면 데이터 발행 안 됨

***

### callbackFlow

- 기존의 콜백 기반(이벤트) API를 Flow로 변환할 때 사용
- **offer()**: 값을 Flow로 보냄
- **cancel() / close()**: Flow 스트림을 종료
- **awaitClose()**: 종료까지 대기, 클린업 등 리소스 해제 구간

***

### asFlow(), asLiveData()

- **asFlow()**: 기존 컬렉션/값/이벤트 등을 Flow로 변환 (예: List.asFlow())
- **asLiveData()**: Flow를 Android LiveData로 변환 (MVVM 등에서 UI 바인딩용)

***

**요약:**

- `CoroutineExceptionHandler`: 코루틴 예외 처리용 핸들러
- `Channel`: 코루틴끼리 값 주고받는 핫 스트림(닫기 가능)
- `Flow`: 콜드 데이터 스트림/비동기 시퀀스, emit/collect/flowOn
- `callbackFlow`: 콜백 API를 콜드 Flow로 변환, offer/close/awaitClose
- `asFlow()`, `asLiveData()`: 기존 객체를 Flow나 LiveData로 변환하는 헬퍼

### 정리

- 코루틴은 비동기 프로그래밍을 간단하고 효율적으로 만들어주는 도구이다
- 복잡한 비동기 작업을 동기 코드처럼 작성할 수 있다
- Compose UI 는 코루틴 기반으로 동작한다
- 많은 Android 컴포넌트에서 코루틴을 지원한다.



