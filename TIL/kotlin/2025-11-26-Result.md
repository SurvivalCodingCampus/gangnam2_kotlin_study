# Result 패턴

`Result` 패턴은 "성공/실패를 값으로 다루는 에러 처리 방법" 이며, 예외를 던지지 않고 캡슐화해서 전달·조합·변환하는 패턴이다. 특히 `runCatching`과 함께 쓰면 try-catch를 함수형 스타일로
대체할 수 있어서, 도메인 계층·리포지토리 계층의 에러 흐름을 매우 깔끔하게 만들 수 있습니다.

```kotlin
sealed class Result<out D> {
    data class Success<out D>(val data: D) : Result<D>()
    data class Error(val e: Throwable) : Result<Nothing>()
}

```

### 결과를 Result 로 감싸기

```kotlin
suspend fun getTodo(id: Int): Result<Todo> {
    return try {
        Result.Success(data = dataSource.getTodo(id).toTodo())
    } catch (e: Exception) {
        Result.Error(e)
    }
}

```

### Result 패턴 사용시 효과

- enum 과 동일하게 when 과 조합하여 모든 처리를 강제할 수 있다.
- 성공과 실패를 처리할 수 있다.

```kotlin
val repository = TodoRepository()

val result = repository.getTodo(id = 1)

when (result) {
    is Result.Error -> TODO()
    is Result.Success -> TODO()
}

```

### Result 클래스 응용

```kotlin
sealed class Result<out D, out E> {
    data class Success<out D>(val data: D) : Result<D, Nothing>()
    data class Error<out E>(val error: E) : Result<Nothing, E>()
}

```

### Result 패턴 사용시 장점 1

- 타입 안전성 향상

```kotlin
sealed class Result<out T, out E> {
    data class Success<out T>(val data: T) : Result<T, Nothing>()
    data class Error<out E>(val error: E) : Result<Nothing, E>()
}

// 성공이면 T, 실패면 E만 보이니까 Nullable 필요 없음
fun getUser(): Result<User, NetworkError> = TODO()

```

### Result 패턴 사용시 장점 2

- 에러 처리 강제성(컴파일러가 모든 케이스 처리를 강제함)

```kotlin
when (val result = getUser()) {
    is Result.Success -> showUser(result.data)
    is Result.Error -> showError(result.error)  // 둘 다 안 쓰면 컴파일러가 경고/에러
}

```

### Result 패턴 사용시 장점 3

- 에러 타입의 명확한 문서화

```kotlin
sealed class NetworkError {
    object NetworkUnavailable : NetworkError()
    object Timeout : NetworkError()
    data class HttpError(val code: Int) : NetworkError()
}

interface UserRepository {
    suspend fun getUser(id: String): Result<User, NetworkError>
// 시그니처만 봐도 어떤 에러가 오는지 알 수 있음

```

### Result 패턴 사용시 장점 4

- try - catch 남용 방지

```kotlin
// Repository 안에서만 try-catch
override suspend fun getUser(id: String): Result<User, NetworkError> =
    try {
        val dto = api.getUser(id)
        Result.Success(dto.toDomain())
    } catch (e: IOException) {
        Result.Error(NetworkError.NetworkUnavailable)
    } catch (e: SocketTimeoutException) {
        Result.Error(NetworkError.Timeout)
    }

// 호출부는 when 만 사용
when (val result = userRepository.getUser("123")) { /* ... */
}

```

### Result 패턴 사용시 장점 5

- 비즈니스 로직과 에러 처리 분리

```kotlin
// Domain / Repository 쪽: 비즈니스 + 매핑
suspend fun login(id: String, pw: String): Result<User, LoginError> = TODO()

// UI 쪽: 에러 → 메시지/상태 매핑
when (val result = login(id, pw)) {
    is Result.Success -> uiState = UiState.LoggedIn(result.data)
    is Result.Error -> uiState = UiState.Error(toMessage(result.error))
}

```

### Result 패턴 사용시 장점 6

- Nullable 타입 사용 감소

```kotlin
// 나쁜 예: User? + null이면 에러
fun findUserBad(id: String): User? = TODO()

// 좋은 예: 성공/실패를 분리
fun findUser(id: String): Result<User, UserError> = TODO()

when (val result = findUser("123")) {
    is Result.Success -> {
        val user: User = result.data  // non-null
    }
    is Result.Error -> { /* ... */
    }
}

```

### Result 패턴 사용시 장점 7

- 테스트 용이성

```kotlin
@Test
fun `login 성공 시 홈으로 이동`() {
    val fakeRepo = object : UserRepository {
        override suspend fun getUser(id: String) =
            Result.Success(User(id = "123", name = "Test"))
    }
}

```

### Result 패턴 사용시 장점 8

- 패턴 매칭을 통한 가독성 향상

```kotlin
fun toErrorMessage(error: NetworkError): String =
    when (error) {
        NetworkError.NetworkUnavailable -> "네트워크를 확인해 주세요."
        NetworkError.Timeout -> "요청 시간이 초과되었습니다."
        is NetworkError.HttpError -> "서버 오류 (${error.code})가 발생했습니다."
    }

// Result + when 조합으로 “성공/실패 + 세부 에러”를 한 눈에
when (val result = repo.getPhotos()) {
    is Result.Success -> showPhotos(result.data)
    is Result.Error -> showToast(toErrorMessage(result.error))
}

```

### 정리

- Result 패턴은 성공과 실패를 명확하게 처리한다
- sealed class 는 서브타입을 봉인한다.
- sealed class 는 패턴매칭을 활용하여 모든 서브타입에 대한 처리를 하기 용이하다
- 예외 throw 없이 값으로 에러를 처리하며, 명확한 타입 구분을 지원한다
- Result 패턴은 when을 활용하여 모든 성공과 실패의 처리를 강제한다
- 앱의 규모에 따라 Result 클래스 버전 1 또는 버전 2를 선택한다
