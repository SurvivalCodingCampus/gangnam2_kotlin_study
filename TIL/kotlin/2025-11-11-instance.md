# 인스턴스(instance) 기본 조작

- Java에서 모든 클래스는 Object 클래스의 메서드와 프로퍼티를 가지고 있다.
- Kotlin에서는 Any, 하지만 근본은 Object를 따름.

> 코틀린의 Any 클래스는 모든 코틀린 클래스의 최상위 부모 클래스로, 자바의 Object 클래스와 유사한 역할을 합니다.
> 클래스를 정의할 때 별도로 상속을 명시하지 않으면 자동으로 Any 클래스를 상속받습니다.

제공 메서드

```kotlin
open operator fun equals(other: Any?): Boolean
open fun hashCode(): Int
open fun toString(): String

```

### Java Object와의 차이점

코틀린의 Any는 자바의 Object보다 더 경량화되어 있습니다.  
Object는 11개 이상의 메서드(예: wait(), notify() 등 스레드 관련 메서드)를 포함하지만, Any는 3개의 핵심 메서드만 제공합니다.  
또한 Any는 non-nullable 타입이지만, nullable이 필요한 경우 Any?를 사용할 수 있습니다.

### equals() 재정의

```kotlin
fun main() {
    var heroes = mutableListOf<Hero>()

    val h1 = Hero()
    val h2 = Hero()

    heroes.add(h1)
    println(heroes.size)

    heroes.remove(h2)
    println(heroes.size)
}
```

Hero class 안에 이렇게 되어 있어요.

```kotlin
override fun equals(other: Any?): Boolean {
    // 두 객체가 동일한 참조인지 확인 (같은 메모리 주소)
    if (this === other) return true

    // 두 객체가 같은 클래스 타입인지 확인
    if (javaClass != other?.javaClass) return false

    return true
}

override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (javaClass != other?.javaClass) return false

    other as Hero

    if (hp != other.hp) return false
    if (mp != other.mp) return false

    return true
}
```

### hashCode() 재정의

```kotlin
override fun hashCode(): Int {
    return javaClass.hashCode()
}

override fun hashCode(): Int {
    var result = hp
    result = 31 * result + mp
    return result
}
```

```text
왜 31을 곱하는가?
31은 해시코드 계산에서 **관례적으로 사용되는 소수(prime number)** 입니다.
31을 사용하는 이유는:
1. 소수이므로 해시 충돌을 줄입니다.
2. 2^5 - 1이므로 컴파일러가 비트 연산으로 최적화할 수 있습니다. (31 * i == (i << 5) - i)
3. 충분히 크면서도 작은 값이어서 오버플로우 가능성이 적습니다.

```

### Set, Map 의 동작 원리

Set, Map 계열은 요소를 검색할 때 hashCode 를 사용하여 빠르다.
List는 순차검색이라 느림

1. 모든 객체는 해시값을 가진다.
2. 동일한 객체는 항상 같은 해시값을 가진다.
3. 하지만, 같은 해시값이라고 항상 동일한 객체는 아니다.

> 1. 검색 성능 비교
     Set과 Map의 검색 속도
     HashSet과 HashMap은 해시 테이블을 사용하여 평균 O(1) 시간 복잡도로 검색합니다. 이는 해시값을 통해 데이터의 위치를 직접 계산하기 때문입니다.
> 2. List의 검색 속도
     List는 순차 검색을 사용하여 O(n) 시간 복잡도를 가집니다. 최악의 경우 모든 요소를 확인해야 합니다.

| 컬렉션           | 검색       | 삽입       | 삭제       | 순서 보장  | 중복 허용          |
|---------------|----------|----------|----------|--------|----------------|
| List          | O(n)     | O(1)*    | O(n)     | ✓      | ✓              |
| HashSet       | O(1)     | O(1)     | O(1)     | ✗      | ✗              |
| LinkedHashSet | O(1)     | O(1)     | O(1)     | ✓(삽입순) | ✗              |
| TreeSet       | O(log n) | O(log n) | O(log n) | ✓(정렬)  | ✗              |
| HashMap       | O(1)     | O(1)     | O(1)     | ✗      | Key ✗, Value ✓ |

*끝에 추가하는 경우

### 리스트에서 요소 정렬

List.sorted() 메서드는 Comparable 을 구현한 객체를 가지는 컬렉션 내부를 정렬해 줌

미리 정렬 규칙을 정하기 위한 Comparable 인터페이스

```kotlin
/**
 * Classes which inherit from this interface have a defined total ordering between their instances.
 */
public actual interface Comparable<in T> {
    /**
     * Compares this object with the specified object for order. Returns zero if this object is equal
     * to the specified [other] object, a negative number if it's less than [other], or a positive number
     * if it's greater than [other].
     */
    public actual operator fun compareTo(other: T): Int
}
```

### 즉석에서 정렬 규칙을 정하기 위한 Comparator 인터페이스

> Comparator는 자바의 java.util 패키지에 속하는 함수형 인터페이스로, 두 객체를 비교하여 정렬 순서를 정의하는 데 사용됩니다.  
> Comparator는 객체를 담고 있는 컬렉션의 정렬 순서를 외부에서 정의할 수 있도록 하는 인터페이스입니다.  
> 기본 정렬 방식 외에 다른 기준으로 정렬하고 싶을 때 사용합니다.

```kotlin
public interface Comparator<T> {
    int compare(T o1, T o2);
}

```

```text
compare() 메서드의 반환값
compare(o1, o2) 메서드는 두 객체를 비교하여 정수값을 반환합니다.
- 양수 반환: o1이 o2보다 크다 → o1을 뒤에 배치 (위치 변경 안 함)
- 0 반환: o1과 o2가 같다 → 위치 변경 안 함
- 음수 반환: o1이 o2보다 작다 → o1을 앞에 배치 (위치 변경)
```

Comparable과의 차이점

| 특징     | Comparable     | Comparator          |
|--------|----------------|---------------------|
| 위치     | 클래스 내부에 구현     | 외부에서 별도 정의          |
| 메서드    | compareTo(T o) | compare(T o1, T o2) |
| 비교 대상  | 자기 자신과 매개변수    | 두 매개변수 객체           |
| 정렬 기준  | 단일 기본 정렬       | 다양한 정렬 기준 가능        |
| 수정 가능성 | 클래스 수정 필요      | 클래스 수정 불필요          |

Comparator 객체를 구현한 예

```kotlin
val results = heroes.sortedWith { a, b -> a.name.compareTo(b.name) }

val results = heroes.sortedWith(compareBy { it.name })

val results = heroes.sortedBy { it.name }
```

### 인스턴스의 복사

> 얕은 복사 (Shallow Copy)  
> 얕은 복사는 객체의 주소값(참조값)을 복사하는 방식입니다.  
> 복사된 객체는 원본 객체와 같은 메모리 주소를 참조하므로, 한쪽을 변경하면 다른 쪽도 영향을 받습니다.

```kotlin
class Student(var id: Int, var name: String, var score: Int)

fun main() {
    val student1 = Student(1, "Alice", 90)
    val student2 = student1  // 얕은 복사

    student2.score = 100  // student2 수정

    println(student1.score)  // 100 출력 (원본도 변경됨!)
    println(student1 === student2)  // true (같은 객체)
}
```

```kotlin
class Address(
    var street: String,
)

class Person(
    val name: String,
    val age: Int,
    val address: Address,
) {
    fun shallowCopy() = Person(name, age, address) // 주소 객체는 같은 참조
}
```

```text
얕은 복사의 특징:
- 같은 메모리 주소를 참조합니다
- 한 객체를 수정하면 다른 객체도 변경됩니다
- 복사 속도가 빠릅니다
- 메모리를 효율적으로 사용합니다
```

> 깊은 복사 (Deep Copy)  
> 깊은 복사는 객체의 실제 값을 복사하여 새로운 메모리 공간에 독립적인 객체를 생성합니다.   
> 복사된 객체와 원본 객체는 완전히 독립적입니다.

```kotlin
class Address(
    var street: String,
)

class Person(
    val name: String,
    val age: Int,
    val address: Address,
) {
    fun shallowCopy() = Person(name, age, address.deepCopy()) // 주소 객체도 새로 생성
}
```

비교 요약

| 특징     | 얕은 복사          | 깊은 복사     |
|--------|----------------|-----------|
| 복사 대상  | 주소값(참조)        | 실제 값      |
| 메모리    | 같은 주소 참조       | 새로운 주소 할당 |
| 독립성    | 원본과 연결됨        | 원본과 독립적   |
| 성능     | 빠름             | 상대적으로 느림  |
| 메모리 사용 | 효율적            | 더 많이 사용   |
| 안전성    | 낮음 (의도치 않은 변경) | 높음 (독립적)  |

### data class

Kotlin 에서는 data class 로 정의하면 copy()를 통해 얕은 복사를 제공함.

```kotlin
data class Person(
    val name: String,
    val age: Int,
)

fun main() {
    val person1 = Person("kim", 10)
    val person2 = Person("lee", 20)

    println(person1 === person2) // false

    val person3 = person1.copy()
    println(person1 === person3) // false
}
```

**data class 효과**
다음 메서드를 재정의 해 준다

- equals()
- hashCode()
- toString()

다음 메서드를 추가해 준다. 얕은 복사 기본 지원

- copy()































