# 2025-10-30 목요일 / 클래스 레퍼런스 타입과 참조

> Kotlin은 JVM 위에서 실행되기 때문에 Java와 동일한 메모리 구조를 사용합니다.

## 클래스 레퍼런스

**스택(Stack) 영역**
스택 영역은 지역변수와 매개변수가 저장되는 공간입니다. 함수 호출과 함께 할당되며, 함수 호출이 완료되면 소멸하는 특징을 가지고 있습니다.  
LIFO(Last In First Out) 구조로 메모리의 높은 주소에서 낮은 주소 방향으로 할당됩니다.

- Primitive 타입(Int, Long, Boolean 등)의 변수 값이 직접 저장됩니다.
- 참조형 타입 변수의 경우 **참조값(주소)**만 스택에 저장되고, 실제 객체는 힙 영역에 존재합니다.

***

**힙(Heap) 영역**  
힙 영역은 모든 클랙스 인스턴스와 배열에 대한 메모리가 할당되는 런타임 데이터 영역입니다.  
JVM의 가비지 컬렉터(GC)가 더 이상 사용하지 않는 객체의 메모리를 회수 합니다.  
메모리의 낮은 주소에서 높은 주소 방향으로 할당됩니다.

---

## companion object

> companion object는 실제 객체 인스턴스

companion object는 **static이 아니라 실제 객체(인스턴스)**입니다. 클래스가 메모리에 로드될 때 동반되어 함께 생성되는 싱글톤 객체입니다.

```kotlin
class MyClass {
    companion object {
        val prop = "companion"
        fun method() = "method"
    }
}

fun main() {
    // 축약 표현
    MyClass.prop
    MyClass.method()

    // 실제로는 객체에 접근하는 것
    MyClass.Companion.prop
    MyClass.Companion.method()

    // 객체를 변수에 할당 가능
    val companionObj = MyClass.Companion
    println(companionObj.prop)
}

```

디컴파일된 Java 코드 차이  
Kotlin 코드를 Java로 디컴파일하면 차이가 명확히 보입니다.

```kotlin
class MyClass {
    companion object {
        const val STATIC_CONST = "real static"
        val NOT_STATIC = "not static"
    }
}

fun main() {
    val myClass = MyClass()
}
```

디컴파일된 Java 코드:

```java
public final class MyClass {
    @NotNull
    public static final Companion Companion = new Companion((DefaultConstructorMarker) null);
    @NotNull
    public static final String STATIC_CONST = "real static";
    @NotNull
    private static final String NOT_STATIC = "not static";

    @Metadata(
            mv = {2, 2, 0},
            k = 1,
            xi = 48,
            d1 = {"\u0000\u0014\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0002\b\u0003\n\u0002\u0010\u000e\n\u0002\b\u0004\b\u0086\u0003\u0018\u00002\u00020\u0001B\t\b\u0002¢\u0006\u0004\b\u0002\u0010\u0003R\u000e\u0010\u0004\u001a\u00020\u0005X\u0086T¢\u0006\u0002\n\u0000R\u0014\u0010\u0006\u001a\u00020\u0005X\u0086D¢\u0006\b\n\u0000\u001a\u0004\b\u0007\u0010\b¨\u0006\t"},
            d2 = {"Lcom/ezlevup/my/day04/MyClass$Companion;", "", "<init>", "()V", "STATIC_CONST", "", "NOT_STATIC", "getNOT_STATIC", "()Ljava/lang/String;", "Sources of kotlinstudy.main"}
    )
    public static final class Companion {
        private Companion() {
        }

        @NotNull
        public final String getNOT_STATIC() {
            return MyClass.NOT_STATIC;
        }

        // $FF: synthetic method
        public Companion(DefaultConstructorMarker $constructor_marker) {
            this();
        }
    }
}
```

### 메모리 구조 비교

| 구분       | Kotlin companion object | Java static         |
|----------|-------------------------|---------------------|
| 본질       | 실제 객체 인스턴스 (런타임 싱글톤)    | 정적 멤버 (JVM 레벨)      |
| 메모리 영역   | Heap 영역 (객체로 생성)        | Method Area (정적 영역) |
| 접근 방식    | 객체를 통한 접근 (축약 표현 가능)    | 클래스명으로 직접 접근        |
| 변수 할당    | 가능 (MyClass.Companion)  | 불가능                 |
| 인터페이스 구현 | 가능                      | 불가능                 |
| 상속       | 가능                      | 불가능                 |

---

### const val, val 핵심 차이점

| 구분    | const val | val           |
|-------|-----------|---------------|
| 할당 시점 | 컴파일 타임    | 런타임           |
| 초기화   | 반드시 리터럴 값 | 함수 호출, 계산식 가능 |

```kotlin
class MyClass {
    companion object {
        const val COMPILE_TIME = "hello"  // ✅ 컴파일 시 결정
        const val CALCULATED = max(1, 2)  // ❌ 불가능! 런타임 함수

        val RUNTIME = "hello"  // ✅ 런타임에 할당
        val CALCULATED = max(1, 2)  // ✅ 가능
    }
}

```

### 사용 가능한 타입

const val:

- Primitive 타입만 가능: String, Int, Long, Boolean, Double, Float, Char, Byte, Short
- 리터럴 값만 할당 가능

```kotlin
companion object {
    const val COUNT = 10  // ✅
    const val NAME = "test"  // ✅
    const val LIST = listOf(1, 2, 3)  // ❌ 불가능
}

```

val:

- 모든 타입 가능
- 함수 호출, 객체 생성 가능

```kotlin
companion object {
    val LIST = listOf(1, 2, 3)  // ✅
    val TIME = System.currentTimeMillis()  // ✅
    val CONFIG = Config()  // ✅
}

```

### 정리

| 항목      | const val           | val                           |
|---------|---------------------|-------------------------------|
| 할당 시점   | 컴파일 타임              | 런타임                           |
| Java 변환 | public static final | private static final + getter |
| 접근 방식   | 직접 필드 접근            | Getter 메서드 호출                 |
| 인라인 여부  | 인라인됨                | 인라인 안됨                        |
| 타입 제한   | Primitive만          | 모든 타입                         |
| 성능      | 가장 빠름               | 약간 느림                         |
| 사용 용도   | 진짜 상수               | 런타임 결정 값                      |

---

## companion object 초기화 시점

companion object는 클래스가 처음 로딩(메모리에 적재)되는 순간 즉시 한 번만 초기화됩니다.

