# 설계 원칙, 디자인 패턴

### 좋은 설계 원칙이란?

- 널리 알려진 설계 원칙을 배우고 의식하며 개발을 하자.

### 응집도와 결합도

- 응집도 (Cohesion)
    - 모듈이 하나의 목적을 수행하는 요소들간의 연관성 척도
    - 모듈 내부의 기능적인 응집 정도를 나타냄

- 결합도 (Coupling)
    - 모듈이 다른 모듈에 의존하는 정도의 척도
    - 모듈과 모듈간의 상호 결합 정도를 나타냄

### 결합도 낮추기, 응집도 높이기

- 결합도가 낮으면(모듈 간 의존이 적으면) 한 부분을 바꿀 때 다른 부분에 영향을 주지 않습니다.
- 응집도가 높으면(모듈이나 클래스가 하나의 역할에 집중하면) 변경이 필요할 때 수정 범위가 작고 오류 위험이 줄어듭니다.[3]

### 결합도 (Coupling) 예제

**❌ 높은 결합도** - 구체 클래스에 직접 의존

```kotlin
class EmailSender {
    fun sendEmail(to: String, message: String) {
        println("Email sent to $to: $message")
    }
}

class OrderService {
    private val emailSender = EmailSender() // 구체 클래스에 직접 의존

    fun placeOrder(orderId: String) {
        println("Order $orderId placed")
        emailSender.sendEmail("user@example.com", "Order confirmed")
        // EmailSender를 바꾸려면 이 클래스를 수정해야 함
    }
}
```

**✅ 낮은 결합도** - 인터페이스를 통한 의존

```kotlin
interface NotificationSender {
    fun send(to: String, message: String)
}

class EmailSender : NotificationSender {
    override fun send(to: String, message: String) {
        println("Email sent to $to: $message")
    }
}

class SmsSender : NotificationSender {
    override fun send(to: String, message: String) {
        println("SMS sent to $to: $message")
    }
}

class OrderService(private val notificationSender: NotificationSender) {
    fun placeOrder(orderId: String) {
        println("Order $orderId placed")
        notificationSender.send("user@example.com", "Order confirmed")
        // 구현체를 자유롭게 교체 가능
    }
}

fun main() {
    val emailService = OrderService(EmailSender())
    val smsService = OrderService(SmsSender())
}
```

## 응집도 (Cohesion) 예제

**❌ 낮은 응집도** - 하나의 클래스가 너무 많은 책임

```kotlin
class UserManager {
    fun createUser(name: String) {
        println("User $name created")
    }

    fun sendWelcomeEmail(email: String) {
        println("Welcome email sent to $email")
    }

    fun calculateDiscount(price: Double): Double {
        return price * 0.9
    }

    fun generateReport() {
        println("Report generated")
    }
    // 사용자 관리, 이메일, 할인, 리포트... 너무 많은 일을 함
}
```

**✅ 높은 응집도** - 각 클래스가 하나의 책임만 가짐

```kotlin
class UserRepository {
    fun createUser(name: String) {
        println("User $name created in database")
    }

    fun findUser(id: String): String {
        return "User $id"
    }
}

class EmailService {
    fun sendWelcomeEmail(email: String) {
        println("Welcome email sent to $email")
    }
}

class DiscountCalculator {
    fun calculateDiscount(price: Double): Double {
        return price * 0.9
    }
}

class ReportGenerator {
    fun generateUserReport() {
        println("User report generated")
    }
}
```

### 좋은 코드를 위해 의식해야 하는 6가지 코드 작성의 원칙

1. DRY
2. PIE
3. SRP
4. OCP
5. SDP
6. ADP

### DRY - Don't Repeat Yourself : 같은 것을 몇번씩 반복하지 말라.

- 중복 코드가 있다면 메소드로 분리한다.

### PIE - Program Intently and Expressively : 명확하고 표현력 있게 기술하자.

- 애매한 이름은 쓰지 말자.
- 누가 봐도 알기 쉬운 이름을 쓰자
- 컨벤션을 따르자
- 매직 넘버에 이름을 붙이자.

```kotlin
val value = 100
val tax = 1.1
val result = value * tax    // value * 1.1 보다 알기 쉬움

```

### SRP - Single Responsibility Principle : 클래스에 주어진 책임은 1개뿐

- 단일 책임 원칙
- 1개의 클래스는 1개의 일만한다.
- 클래스는 하나의 기능이나 책임만을 가져야 하면, 그 책임이 변경될 때 해당 클래스만 수정하면 된다.
- 하지만 적절한 수준의 클래스 분리를 유지하는 것이 중요하다.

bad

```kotlin
class TodoRepository {
    private val dataSource = TodoDataSource()

    suspend fun getTodo(id: Int): Todo {
        return dataSource.getTodo(id).toTodo()
    }

    suspend fun getTodos(): List<Todo> {
        return dataSource.getTodos()
            .filter { it.id != null && it.userId != null }
            .map { it.toTodo() }
    }
}

```

good

```kotlin
class TodoRepository(
    private val dataSource: TodoDataSource,
) {
    suspend fun getTodo(id: Int): Todo {
        return dataSource.getTodo(id).toTodo()
    }

    suspend fun getTodos(): List<Todo> {
        return dataSource.getTodos()
            .filter { it.id != null && it.userId != null }
            .map { it.toTodo() }
    }
}

```

외부 객체는 생성자로 주입 받아라.

### OCP - Open Closed Principle : 개방 폐쇄 원칙

- 확장에 대해서는 열려있고 (확장은 자유롭고), 변경에 대해서는 닫혀있다 (의존 부분의 변경은 불필요)
- 즉, 수정 없이 확장 가능하도록 하자.
- Iterable, Comparator 등이 좋은 예
- String 의 경우는 상속 금지이므로 OCP에 반하는 클래스의 대표적인 예.
- 인터페이스를 적극 활용하여 확장 가능하게 하자.

### SDP - Stable Dependencies Principle : 안전한 것에 의존하라.

- ATM 시스템을 예를 들면 암호 처리 같이 한번 완성되면 수정될 가능성이 없는 클래스에 의존할 만 하다
- 하지만 가장 좋은 것은 특정 클래스가 아니라 인터페이스에 의존하는 것이다
- 클래스는 생성자가 변하거나 할 수 있으나 인터페이스는 거의 그대로이니까.

### ADP - Acyclic Dependencies Principle

- 의존성 비순환 원칙
- 의존 관계에 사이클이 발생되지 않게 한다.

### 또 다른 코드 설계 원칙

- SOLID 원칙

| 두문자   | 약어  | 개념                                                                                                                            |
|-------|-----|-------------------------------------------------------------------------------------------------------------------------------|
| **S** | SRP | **단일 책임 원칙 (Single responsibility principle)**<br>한 클래스는 하나의 책임만 가져야 한다.                                                      |
| **O** | OCP | **개방-폐쇄 원칙 (Open/closed principle)**<br>"소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다."                                               |
| **L** | LSP | **리스코프 치환 원칙 (Liskov substitution principle)**<br>"프로그램의 객체는 프로그램의 정확성을 깨드리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다." 계약에 의한 설계를 참고하라. |
| **I** | ISP | **인터페이스 분리 원칙 (Interface segregation principle)**<br>"특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다."                             |
| **D** | DIP | **의존관계 역전 원칙 (Dependency inversion principle)**<br>프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나다.            |

# 디자인 패턴

```text
소프트웨어 디자인 패턴(software design pattern)은 소프트웨어 공학의 소프트웨어 디자인에서 특정 문맥에서 공통적으로 발생하는 문제에 대해 재사용 가능한 해결책이다.

디자인 패턴은 프로그래머가 어플리케이션이나 시스템을 디자인할 때 공통된 문제들을 해결하는데에 쓰이는 형식화 된 가장 좋은 관행이다.

결론 : 설계 원칙과 노하우를 정리한 것. 선배님들이 정리한 것을 공부하자.

```

### 디자인 패턴을 공부했을 때의 장점

- 개발자간에 커뮤니케이션이 원만해 진다.
- 객체지향 설계 원칙의 이해도가 좋아진다.

