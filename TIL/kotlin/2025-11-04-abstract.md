# 추상클래스(abstract)

코틀린의 추상 클래스는 직접 인스턴스화할 수 없고 다른 클래스의 상위 클래스 역할만 하는 미완성된 클래스입니다. 추상 클래스는 여러 클래스의 공통적인 부분을 모아놓고 상속을 통해 구체화되는 설계 명세를 제공합니다.

- 추상 클래스는 `abstract` 키워드와 함께 선언되며, 일반 클래스와 달리 `open` 키워드 없이도 상속이 가능합니다.
- 추상 멤버는 `abstract` 키워드를 붙여 선언하며, 하위 클래스에서 반드시 구현해야 합니다.
- 상속의 재료로 사용 되는 클래스
- 상세 부분이 일부 미정인 클래스

```kotlin
// 추상 클래스
abstract class Character(
    var name: String,
    var hp: Int,
) {
    // 일반 프로퍼티 (완성됨)
    val typeNum: Int = 4

    // 추상 프로퍼티 (하위 클래스에서 구현 필요)
    abstract val width: Int
    abstract val height: Int

    // 일반 메서드 (구현됨)
    fun run() = println("$name 이 도망갔다.")

    // 추상 메서드
    abstract fun attack(slime: Slime)
}

class Dancer(
    name: String,
    hp: Int,
) : Character(name, hp) {
    // 오버라이드 강제
    // Implement members
}
```

# 인터페이스(interface)

- 모든 메소드는 추상 메소드 여야 한다.
- 필드를 가지지 않는다.

### 디폴트 메서드 구현

코틀린 인터페이스는 디폴트 구현이 있는 메서드를 가질 수 있습니다. 자바 8의 default 키워드와 달리, 코틀린에서는 메서드 본문을 메서드 시그니처 뒤에 추가하기만 하면 됩니다:

```kotlin

interface Organism {
    val forceConnection: Int
    fun useForce()
}

interface Alien : Organism {
    fun sleep() {
        println("alien sleeping")
    }
}

interface Human : Organism {
    val numberOfLegs: Int  // 추상 프로퍼티

    fun speak() // 추상 메서드

    val isKing: Boolean
        get() = true  // 디폴트 구현

    fun sleep() {
        println("human sleeping")
    }
}

class Man(override val forceConnection: Int = 10) : Human, Alien {

    override fun useForce() {
        println("man force: $forceConnection")
    }

    override val numberOfLegs: Int
        get() = 2

    override fun speak() {
        println("man speak")
    }

    override fun sleep() {
        super<Alien>.sleep() // 중복된 메서드 처리
        println("man sleep")
    }
}

fun main() {
    val man = Man()
    man.speak()
    man.sleep()
    man.useForce()
    println("numberOfLegs: ${man.numberOfLegs}")
    println("isKing: ${man.isKing}")
}

```

출력:

```text
man speak
alien sleeping
man sleep
man force: 10
numberOfLegs: 2
isKing: true

```

### 인터페이스의 효과

- 같은 인터페이스를 구현한 클래스들은 공통 메소드를 구현하도록 강제된다.
- 어떤 클래스가 인터페이스를 구현하고 있다면, 적어도 그 인터페이스에 정의된 메소드를 가지고 있다는 것이 보장된다.





