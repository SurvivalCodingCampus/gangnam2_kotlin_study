# Flow
- 비동기적으로 계산되는 데이터 **스트림**
- **코루틴**을 기반으로 동작
- 여러 값을 순차적으로 방출할 수 있다
- **Cold Stream** 방식 (수집하는 시점에 데이터 생성)

## flow() 빌더
- flow 빌더는 코루틴을 사용하여 비동기 스트림을 생성하는데 사용
- `emit()`: Flow 내에서 값을 방출할 때 사용
- flow 빌대 내에서 `suspend` 함수 사용 가능

## 사용 예

```kotlin
val basicFlow = flow {
    for (i in 1..3) {
        delay(100)
        println("Emitting $i")
        emit(i)
    }
}
basicFlow.collect { value ->
    println("Collected: $value")
}
```
- `collect()`: Flow의 값을 소비하기 위해 사용되는 함수
- Flow는 `collect()`되는 시점에 값이 방출된다 (**Cold**)

## StateFlow
- `StateFlow`는 코루틴에서 제공하는 특별한 **Hot** 스트림 Flow
- 상태 변화를 관찰하고, 최신 상태를 유지하는데 유용하다. 안드로이드에서 주로 UI 상태 관리에 사용된다
- 항상 최신 상태를 유지 (소비되지 않고 마지막 값이 남아 있다)
- Thread Safe
- `StateFlow`는 **읽기 전용**, `MutableStateFlow`는 상태 변경 가능
- `StateFlow`는 초기값이 필수
- 구독자가 필요할 때 값을 얻는다
- 값이 변경될 때만 구독자에게 값을 전달함
- value 프로퍼티로 값을 get/set 할 수 있다
- `Flow`가 **Cold 스트림**, `StateFlow`는 **Hot 스트림**
- UI 작업을 위해서는 데이터 홀더로써 `StateFlow` 사용이 일반적

## SharedFlow
- 초기값을 가지지 않는다
- 데이터를 읽어 들이기 전에는 아무값도 없는 데이터에 적합
- **원타임 이벤트**를 처리할 때 유용

## Cold Stream
### 구독자가 있을 때만 흐른다.
- 수집(collect)하는 순간부터 데이터가 생성되기 시작한다
- 각 subscribe(collector)마다 독립적인 스트림을 가진다
  - 여러 번 collect하면 데이터를 처음부터 다시 발생시킨다

### 예시
```kotlin
val flow = flow {
    println("Flow 시작!")
    emit(1)
    emit(2)
    emit(3)
}

flow.collect { println(it) }
flow.collect { println(it) }
```
```text
Flow 시작!
1
2
3
Flow 시작!
1
2
3
```

### 왜 Cold 일까?
- 구독이 들어오기 전까지 가만히 멈춰있기 때문이다
- 아무도 보지 않으면 데이터가 "얼어있는" 상태라고 이해할 수 있다

## Hot Stream
### 구독자와 상관없이 계속 흐른다.
- 구독 여부와 관계 없이 데이터가 흘러간다
- 여러 구독자가 같은 데이터를 공유한다
- 구독 시점에 이미 지나간 데이터는 못 받을 수 있다

### 예시
```kotlin
val shared = MutableSharedFlow<Int>()

launch {
    shared.collect { println("collector1: $it") }
}

launch {
    shared.collect { println("collector2: $it") }
}

delay(100)
shared.emit(1)
shared.emit(2)
```

### 왜 Hot 일까?
- 누구든 보든 말든 **계속 에너지를 뿜고 있기 때문**
- 이미 "시동이 걸려 있는" 상태의 스트림
