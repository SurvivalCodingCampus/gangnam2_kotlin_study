# 비동기 프로그래밍

## 동기 vs 비동기

- 작업 완료를 기다리는 방식의 차이
- 동기 : 한 작업이 끝날때까지 기다렸다가 다음 작업을 시작함
- 비동기 : 기다리지 않고 다른 작업을 시작함

## 동기(Synchronous) 프로그래밍

- 코드가 순서대로 실행된다.
- 작업이 완료될 때까지 프로그램이 중단될 수 없다.
- 모든 작업은 이전 작업의 실행이 완료될 때까지 기다려야 한다.
- 코드의 실행 순서가 예측 가능하다

## 비동기(Asynchronous) 프로그래밍

- 여러 작업이 병렬로 실행될 수 있다
- 한 작업이 완료 여부와 관계없이 다음 작업을 시작할 수 있다
- 작업의 완료 순서를 예측할 수 없다
- I/O 작업이나 네트워크 요청과 같이 시간이 오래 걸리는 작업에 유용하다

## 동시성 vs 병렬성

- 여러 작업을 처리하는 방식에 대한 차이
- 동시성 : 여러 작업을 번갈아가면 처리하는 것
- 병렬성 : 여러 작업을 실제로 동시에 처리하는 것

## 동시성(Concurrency)

- 여러 작업이 논리적으로 동시에 실행되는 것처럼 보이는 개념
- 시분할 방식으로 여러 스레드를 활용해 동시성을 구현할 수 있음

## 병렬성(Parallelism)

- 여러 작업이 물리적으로 동시에 실행되는 개념
- 멀티코어 환경에서 실제로 여러 스레드가 병렬로 실행될 수 있음

## 동기(sync) 프로그래밍

- 코드가 순서대로 실행된다.
- 작업이 완료될 때까지 프로그램이 중단될 수 없다.
- 모든 작업은 이전 작업의 실행이 완료될 때까지 기다려야 한다.

## 비동기(async) 프로그래밍

- 임의의 순서로 또는 동시에 작업이 실행될 수 있다.
- 비동기를 처리하는 방법에는 Java의 Thread, 콜백, Future 방식이 있다.
- 그리고 Kotlin의 Coroutine 이 있음

## 왜 코루틴을 써야 하는지?

- Java 의 기본 API (Thread) 로도 충분히 가능한데 왜 코루틴을 배워야하는가?

## 현재 Thread 확인

```kotlin
println(Thread.currentThread())
```

프로그램은 main 스레드에서 실행 됨

## 단일 Thread의 문제점

- 모든 인스턴스는 main 스레드에서 생성되며 처리 된다
- Thread 를 Block 하는 동안 (sleep 메서드) 프로그램이 멈춘다

## 코루틴의 등장

- 코틀린 1.3에 추가
- 경량
- 메모리 누수 감소
- 기본 제공 취소 지원
- Jetpack 통합 (모던 안드로이드 개발을 위한 라이브러리 모음집)
- 구글은 이후에 비동기 처리 방식은 kotlin 과 코루틴을 권장하게 됨
- 자바로 개발할 때 최대 단점은 코루틴을 쓸 수 없는 것

## Coroutine

- Kotlin 표준 병행 프로그래밍 API
- 코루틴은 오래 걸리는 작업을 수행하는 방법 중 우아하고 효율적인 방법 중 하나이다
- 콜백 기반 코드를 순차 코드로 변환할 수 있다
- 순차 코드는 읽기 쉽고 에러 처리가 편하다

## Coroutine과 suspend 함수

```kotlin
fun runMain(): Job = GlobalScope.launch {
    val data = Weathers.tomorrow()
    println("내일 날씨는: $data")
}

suspend fun Weathers.tomorrow(): String {
    delay(2000) // 2초가 처리 // 스레드가 블록되지 않음
    return "맑음"
}
```

## 일반적인 멀티태스킹과 코루틴

- 일반적으로는 하나의 코루틴이 특정한 스레드에서 동작
- 코틀린 코루틴은 suspend와 resume을 통해 스레드를 **양보**한다
- 코루틴은 비동기식이며 스레드를 **차단하지 않는다**
- 코루틴은 **일시 중단 함수**를 사용하여 비동기 코드를 **순차적**으로 만든다

## Coroutine 사용시 이점

- 경량
    - 코루틴은 실행 중인 스레드를 차단하지 않는 정지(suspend)를 지원하여 메모리를 절약하면서 많은 동시 작업을 처리한다
- 메모리 누수 감소
    - 스레드를 활용한 동기화는 휴먼 에러에 의한 메모리 누수나 데드락과 같은 위험이 존재하지만, 코루틴은 안전하다
- 스레드보다 가볍고 효율적이다
- 많은 안드로이드 API 가 지원하고 있다

## 코루틴의 주요 컨셉

- 다른 언어의 async, await 같은 키워드가 제공되지 않는다
- 대신 정지 함수를 활용한 안전하고 에러가 발생하지 않는 비동기 처리에 중점을 두고 있음

## delay

`public suspend fun delay(timeMillis: Long)`

- suspend 함수는 일정시간 코루틴을 일시 정지함
- 코루틴이 정지되어도 Main Thread 는 차단되지 않음
- suspend 함수는 CoroutineScope 블록 또는 다른 suspend 함수에서 호출 가능

## suspend

- suspend는 비동기 함수를 표기하는 코틀린 문법이다
- suspend 함수가 실행되면 완료될 때까지 일시 중지 됨
- 그 사이 다른 함수나 코루틴이 실행될 수 있음

## CoroutineScope 정리

- 모든 코루틴을 추적하여 코루틴이 실행되어야 하는 시기를 관리하는 구성요소
- 모든 비동기 작업은 특정 스코프에서 실행되어야 함
- 코루틴은 스코프에 의존적이다
- 적절한 스코프가 없으면 전역적인 스코프인 GlobalScope를 사용 가능 (비추천)

## Job

- CoroutineBuilder 에 의해 작성된 코루틴
- launch 는 Job을 리턴한다
- Job 을 통해 실행중인 코루틴을 제어할 수 있다

## Dispatcher

- 코루틴이 어떤 스케줄러에 의해 수행될지를 지정할 수 있다
- Default
    - 백그라운드 스레드
- 코어 수에 비례해서 스레드를 만든다. 연산용
- CPU에 부하를 줄 만한 처리 (로컬에서 List 정렬 등)
- Main
    - 메인 스레드에 연결되는 디스패처
- IO
    - 백그라운드 스레드
    - Input/Output 조작용
    - 상대적으로 많은 스레드를 만드는 디스패처 (DB 통신 / Http 통신)
- Unconfined
    - 특정 스레드를 한정하지 않음. 공식 문서에서는 보통 사용하지 않는다고 명시되어 있음
